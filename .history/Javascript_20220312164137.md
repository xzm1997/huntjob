## JS数据类型
- 基本数据类型（简单数据类型）
    - 存储在栈中的简单数据段
    - Undefined、Null、Boolean、Number 、string、Symbol
- 引用数据类型（复杂数据类型）
    - 存储在堆中的对象，存储在栈中的值是一个指针，指向 存储对象的内存地址
    - 函数，对象，数组等
- Symbol 本质上是一种唯一标识符，可用作对象的唯一属性名，这样其他人就不会改写或覆盖你设置的属性值。
- typeof 能判断类型有：number、string、boolean、symbol、undefined、function；
- 原始值是存储在栈中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。 
- 引用值是存储在堆中的对象，也就是说，存储在变量处的值是一个指针，指向存储对象的内存处。
- ECMAScript中有5种原始类型，即undefined、null、number、string、boolean。


## 匿名自执行函数
- 匿名自执行函数首先是一个匿名函数，但是这个函数是可以自己自动执行的，不需要借助其他的元素。


## 实现闭包
- 闭包是js的一种特性，我们可以通过闭包实现函数内外部的连接，并且可以使得函数的局部变量始终存在于内存中。
- 匿名自执行函数还可以用于在js中模拟创建块级作用域，即如果使用匿名自执行函数将某些代码包裹起来可以实现块级作用域的效果，减少全局变量的数量，在匿名自执行函数执行结束后变量就会被内存释放掉，从而也会节省了内存。
- 闭包允许内层函数引用父函数中的变量，但该变量是最终值
- 闭包内变量要到整个闭包被清除的时候才会清除，比如局部变量要等到函数执行完之后。


## 变量与函数提升
- javascript只有函数作用域， 没有块作用域
- 会将当前作用域的所有变量的声明提升到程序的顶部
- 变量声明、函数声明都会被提升到作用域顶处； 
- 当出现相同名称时，优先级为：变量声明``foo#1`` < 函数声明``foo#2`` < 变量赋值``foo#3``
- 在函数内部可以不声明，就是隐式全局变量。
- 函数会先去找自己内部的变量，内部有就不会往外面找，内部没有才去外面找


## undefined和null
- undefined和null与任何有意义的值比较返回的都是false，但是null与undefined之间互相比较返回的是true。


## 全局声明
- 与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）


## 方法劫持:``apply,call,bind``的用法和区别
- 重新定义``this``对象
- `apply`和`call`会使当前函数立即执行，`bind`会返回一个函数，后续需要时再调用
- `call`是`apply`的语法糖，只有传的参数不同，`call`中要传多个任意参数，`apply`只可以直接传数组或者类数组
- bind是为函数绑定一个this上下文
- 传入null或者undefind和没传一样，还是全局的window
- apply会将一个数组装换为一个参数接一个参数的传递给方法

## DOM相关
- `innerHTML`：是从对象的起始位置到终止位置的全部内容,包括Html标签。
- `innerText`：从起始位置到终止位置的内容, 但它去除Html标签
- `outerHTML`：除了包含`innerHTML`的全部内容外, 还包含对象标签本身。

## 正则表达式
- `/正则表达式主体/修饰符`(可选)
- `i`：执行对大小写不敏感的匹配；
- `g`：执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）；
- `m`：执行多行匹配；
- `[abc]`：查找方括号之间的任何字符。
- `[0-9]`：查找任何从 0 至 9 的数字
- `(x|y)`：查找任何以 | 分隔的选项
- `\d`：查找数字
- `\D` ：匹配一个非数字字符
- `\s`：查找空白字符
- `\b`：匹配单词边界
- `\w`：匹配字母数字或下划线
- `\uxxxx`：查找以十六进制数 xxxx 规定的 Unicode 字符
- `^`：匹配输入的开始。
- `$`：匹配输入的结束。
- `*`：匹配前一个表达式 0 次或多次。等价于{0，}
- `+`：匹配前面一个表达式 1 次或者多次。等价于{1，}
- `?`：匹配前面一个表达式 0 次或者 1 次。等价于{0，1}；非贪心的；
- `.`：默认匹配除换行符之外的任何单个字符。
- `{ }`：个数
- `$1`：第一个分组的值

## 如何判断一个对象是否为Array
- `typeof`：不可行，返回object
- `instanceof`：在多全局对象（跨 frame 对象构建或多个window）的场景下会失效
- `Object.prototype.toString.call(obj) === '[object Array]'`;   

## Math.max(x)
- 函数 Math.max(x);的参数是Number类型，可以是小数，整数，正数，负数或者是0.如果不是上面所述类型就会返回NaN.

## jQuery `toggleClass()`
- `toggleClass()` 对设置或移除被选元素的一个或多个类进行切换。
- 该方法检查每个元素中指定的类。如果不存在则添加类，如果已设置则删除之。这就是所谓的切换效果。


## jQuery 高度与宽度
```
alert($(window).height()); //浏览器当前窗口可视区域高度
alert($(document).height()); //浏览器当前窗口文档的高度
alert($(document.body).height());//浏览器当前窗口文档body的高度
alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin
alert($(window).width()); //浏览器当前窗口可视区域宽度
alert($(document).width());//浏览器当前窗口文档对象宽度
alert($(document.body).width());//浏览器当前窗口文档body的高度
alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin
```
- innerWidth() 方法返回元素的宽度（包括内边距）
- innerHeight() 方法返回元素的高度（包括内边距）


## import
- 用于引用外部CSS


## 不能冒泡的9个事件
- `load`
- `unload`
- `mouseenter`
- `mouseleave`
- `blur`
- `focus`
- `error`
- `resize`
- `abort`从3个角度说可分为**ui事件**、**鼠标移入移出事件**、**聚焦和失焦件**

## 原型重写
- 重写原型对象切断了现有原型与任何之前已经存在的实例之间的联系，他们引用的仍然是最初的原型
- 如果构造函数没有x去原型下找
- 如果有x但是没有赋值，则是undefined,相当于x=undefined.就不会进入原型链了

## 原型
- 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了`null`以外）
- 所有的引用类型（数组、对象、函数），都有一个`__proto__（`隐式原型）属性，属性值是一个普通的对象
- 所有的函数，都有一个prototype（显式原型）属性，属性值也是一个普通对象
- 所有的引用类型（数组、对象、函数），`__proto__`属性值指向（完全相等）它的构造函数的`prototype`属性值
- 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去`__proto__`（即它的构造函数的`prototype`中）寻找。


## `Math.round(x)`
- 如果参数的小数部分等于0.5，则舍入到下一个在正无穷方向上的整数
- 与很多其他语言中的round()函数不同，Math.round()并不总是舍入到远离0的方向

## `in`运算符
- 如果指定的属性在指定的对象或其原型链中，则in 运算符返回true。

## constructor 
- `constructor` 是构造函数属性
- 它是原型属性 `prototype`所指向的那个对象的属性
- Number 对象本身可作为构造函数
- 通过`Object[key] = value`; 形式给`constructor`对象添加`key = 1`属性,对应的`value = 123`

## setTimeout
- 每次for循环的时候`setTimeout`都会执行，因为`setTimeout`是异步函数，里面的`function`则不会立即执行，而是会被放入任务队列
- 只有主线上的全部执行完，才会执行任务队列里的任务
- let有自己的作用域，不同于var

## ECMAScript6 `Promise`
- `Promise`对象代表一个异步操作，有3种状态：等待`pending`、已完成`fulfilled`、已拒绝`rejected`。
- 一个`promise`的状态只可能从**等待**转到**完成**态或者**拒绝**态，不能逆向转换，同时**完成**态和**拒绝**态不能相互转换。
- `promise`必须实现`then`方法（可以说，`then`就是`promise`的核心），而且`then`必须返回一个promise，同一个`promise`的`then`可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致。
- then方法接受两个参数，第一个参数是成功时的回调，在`promise`由**等待**态转换到**完成**态时调用，另一个是失败时的回调，在`promise`由**等待**态转换到**拒绝**态时调用。同时，`then`可以接受另一个`promise`传入，也接受一个类`then`的对象或方法，即thenable对象。

## 事件处理程序
- `btn.onclick = a`     相当于把函数`a`赋值给btn的点击事件处理程序（此时函数`a`不会执行）
- `btn.onclick = a()`   函数`a`执行，打印1并将返回值（函数`b`）赋值给`btn`的点击事件处理程序


## `== ===`区别
- ==判断相等
- ===绝对相等，先比较数据类型是否一样，更加绝对意义上的相等，不会发生自动类型转换
- 赋值操作符（=）的优先级小于三元操作符的优先级

## Sort函数
- `numbers.sort((a,b)=>a-b)`：升序排列
- 等价于`{return (a.value-b.value)}`

## 模块化
- AMD：推崇依赖前置；提前执行；用户体验好，没有延迟，依赖模块提前执行即可——require.js
- CMD：推崇依赖就近；延迟执行；性能好——sea.js

## jQuery
- `siblings()` 方法返回被选元素的**所有**同胞元素。
- `next()` 方法返回被选元素的**下一个**同胞元素。
- `find()` 方法返回被选元素的**后代**元素，一路向下直到最后一个后代。


## 严格模式
- 严格模式下的this在函数体内不会默认指向window，而是指向undefined=
- 严格模式下函数参数不能同名
- 严格模式下，构造函数中this指向实例对象

## 事件对象的方法
- `preventDefault()`取消事件默认行为，如阻止点击提交按钮时对表单的提交
- `stopImmediatePropagation()`取消事件冒泡同时阻止当前节点上的事件处理程序被调用，影响当前的事件
- `stopPropagation()`取消事件冒泡，不影响事件
- `cancelBubbe()`取消事件冒泡
- `returnValue()`取消事件默认行为

## ajax
- Ajax技术核心就是`XMLHttpRequest`对象。
- Ajax技术的工作原理可以分成3步	
    - 创建Ajax对象：new
    - 发送请求：open；send
    - 获取响应：	
      1. 求还没有建立（open执行前）
      2. 请求建立了还没发送（执行了open）
      3. 请求正式发送（执行了send）	
      4. 请求已受理，有部分数据可以用，但还没有处理完成	
      5. 请求完全处理完成
- js是单线程的，浏览器是多线程的。JavaScript 处理异步都是以 callback 的方式


## `try...catch...finally`用法
- `try`块一共有三个关键字`try`,`catch`还有`finally`；
- `finally`语句无论`try`和`catch`执行结果如何都会执行；
- `catch`是捕获到`try`语句块里的错误才会执行；
- `catch`和`finally`语句都是可选的，但你在使用`try`语句时必须至少使用一个（也就是`try`必须搭配`catch`或者`finally`）。
- 如果`try`语句没有使用`finally`，则返回`try`语句中`return`的东西，函数`try...catch`语句之外的`return`不执行
- 如果try语句后面有`finally`，`try`中的`return`不会跳出函数,因为一定要进入`finally`语句，函数`try...finally`语句之外的`return`不执行
- 如果try语句后面有finally，try中就算有break用来跳出语句块，也不管用，只要有finally，不管try和catch语句中执行什么，一定会进入finally语句

## JavaScript的命名规则
- 必须以**字母**、**美元符号**或者**下划线**开头，中间可以是**数字**、**字母**、**下划线**、**美元符号**
- 变量名不能包含**空格**、**加号**、**减号**等符号
- 不能使用JavaScriot中的关键字
- JavaScript的变量名是严格区分大小写的

##对象
- 内部对象：`Array`、`Boolean`、`Date`、`Function`、`Global`、`Math`、`Number`、`Object`、`RegExp`、`String`以及各种错误类对象，包括`Error`、`EvalError`、`RangeError`、`ReferenceError`、`SyntaxError`和`TypeError`。
- 宿主对象：宿主对象就是执行JS脚本的环境提供的对象。对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。不同的浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭！这会带来浏览器兼容问题，增加开发难度，如Window和Documen，Element，form，image，等等。
- 自定义对象：开发人员自己定义的对象。JS允许使用自定义对象，使JS应用及功能得到扩充

##Boolean类型转换
- 对于`String`:只有非空字符串为真
- 对于`Number`:除了`0`和`NaN`之外都为真
- 对于`Boolean`:`true`为真
- 对于`Object`:除了`null`之外都为真
- `undefined`为`false`;
- 在关系运算符中，`null`，`undefined`会被`Number()`强制转换成数字类型；
- 在相等运算符中，`null`，`undefined`则不会转化为数字类型，而是经过特殊处理后转化为`false`

## 迭代器
- 迭代器是一个对象，需要满足：对象内部有方法`next`，`next`方法要求返回对象`done: true`或`false, value:值`
- 如果一个对象，实现了`Symbol.iterator`方法，且这个方法返回一个迭代器，这个方法就是一个生成迭代器的函数

## 回调函数
- 回调函数就是一个被作为参数传递的函数。
- `forEach`方法在数组元素为空时会跳过执行回调函数

## for
- `forEach`方法在数组元素为空时会跳过执行回调函数
- 除了抛出异常以外，没有办法跳出或中止`forEach`方法。如果需要中止或跳出循环，不应该是`forEach`。在`forEach`中使用 `return false` 或者 `break`无法跳出整个循环，并且使用`break`会直接报错

## let
- 不存在变量提升
- 暂时性死区：只要块级作用域内存在、它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
- 不允许重复sheng

## 模块加载机制
- 首先加载核心模块,不管有没有同名/同目录的情况下,核心模块优先加载.
- 其次按照相对路径/绝对路径加载文件模块(加载顺序,首先试图按照路径查找 `.js` 扩展名的文件,如果没有,试图按照路径查找 `.json` 扩展名的文件,如果还是没有,就按照路径查找 `.node` 扩展名的`c++`模块了)
- 最后搜索 `node_modules` 目录下通过`npm`下载的第三方模块. 

## 事件流
- dom2规定的事件流包括3个阶段：事件捕获；处于目标阶段（事件处理）；事件冒泡阶段

## 函数

- 函数声明语法定义：`function sum(num1,num2){return num1+num2}`
- 函数表达式定义函数：
  - `var sum = function(num1,num2){return num1+num2};`
  - `var sum = new Function("num1","num2","return num1+num2")`;
  - `Function`构造函数可以接受任意数量的参数，但最后一个参数始终被看成函数体，注意函数表达式定义函数的方法与声明其他变量时一样需要加分号。

## 数字
- JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。
- Javascript中，由于其变量内容不同，变量被分为基本数据类型变量和引用数据类型变量。基本类型变量用八字节内存，存储基本数据类型(数值、布尔值、`null`和未定义)的值，引用类型变量则只保存对对象、数组和函数等引用类型的值的引用(即内存地址)。
- JS中的数字是不分类型的，也就是没有`byte/int/float/double`等的差异。

## `RegExp` 对象
- `RegExp` 对象的主要方法是 `exec()`，该方法是专门为捕获组而设计的。 `exec()`接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 `null`。


## `get set`使用
- 为内部属性提供了一个方便习惯的读/写方式
- `get`与`set`是方法，因为是方法，所以可以进行判断。
- `get`是得到 一般是要返回的,`set`是设置不用返回
- `getter`、`setter`必须一起用？

## 属性选择器
- 












