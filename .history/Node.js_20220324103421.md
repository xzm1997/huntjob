# 概念
## 特点
- **异步**、**非阻塞**IO模型
- **事件循环**：Node的背后还有一个线程池，线程池会处理长时间运行的任务。线程池里的任务是通过队列和事件循环的机制来执行。
- **单线程**：Node的主线程只有一个。主线程是用于接收客户端请求。但不会处理具体的任务。
- **总结**：轻量和高效

##事件循环机制
- 微任务：
  - `process.nextTick()` 注册的回调
  -` promise.then()` 注册的回调
  - Node在执行微任务时， 会优先执行`nextTick task queue`中的任务，执行完之后会接着执行`promise task queue`中的任务。
![示意图](https://www.hepengfei.net/wp-content/uploads/2021/01/33.png)
- 如果执行了任何非阻塞异步代码（创建计时器、读写文件等），则会进入事件循环。其中事件循环分为六个阶段：
  - **Timers（计时器阶段）**：从图可见，初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含`setTimeout`和`setInterval`），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入`Pending callbacks`阶段。
  - **Pending callbacks**：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。
  - **Idle/Prepare**：仅供内部使用。
  - **Poll（轮询阶段）**：
    - 当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。
    - 当回调队列为空时：但如果存在有计时器（`setTimeout`、`setInterval`和`setImmediate`）没有执行，会结束轮询阶段，进入`Check`阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。
  - **Check（查询阶段）**：会检查是否存在`setImmediate`相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入`Close callbacks`阶段。
  - **Close callbacks**：执行一些关闭回调

## `CommonJS`标准
- 浏览器不兼容`CommonJS`的根本原因，在于缺少四个`Node.js`环境的变量。 `module` `exports` `require` `global`

## 多线程