# 概念
## 特点
- **异步**、**非阻塞**IO模型
- **事件循环**：Node的背后还有一个线程池，线程池会处理长时间运行的任务。线程池里的任务是通过队列和事件循环的机制来执行。
- **单线程**：Node的主线程只有一个。主线程是用于接收客户端请求。但不会处理具体的任务。
- **总结**：轻量和高效

##事件循环机制
- 微任务：
  - `process.nextTick()` 注册的回调
  -` promise.then()` 注册的回调
  - Node在执行微任务时， 会优先执行`nextTick task queue`中的任务，执行完之后会接着执行`promise task queue`中的任务。
![示意图](https://www.hepengfei.net/wp-content/uploads/2021/01/33.png)
- 如果执行了任何非阻塞异步代码（创建计时器、读写文件等），则会进入事件循环。其中事件循环分为六个阶段：
  - **Timers（计时器阶段）**：从图可见，初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含`setTimeout`和`setInterval`），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入`Pending callbacks`阶段。
  - **Pending callbacks**：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。
  - **Idle/Prepare**：仅供内部使用。
  - **Poll（轮询阶段）**：
    - 当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。
    - 当回调队列为空时：但如果存在有计时器（`setTimeout`、`setInterval`和`setImmediate`）没有执行，会结束轮询阶段，进入`Check`阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。
  - **Check（查询阶段）**：会检查是否存在`setImmediate`相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入`Close callbacks`阶段。
  - **Close callbacks**：执行一些关闭回调

## `CommonJS`标准
- 浏览器不兼容`CommonJS`的根本原因，在于缺少四个`Node.js`环境的变量。 `module` `exports` `require` `global`

## 多线程
- `Node.js` 使用两种线程：`event loop` 处理的主线程和 `worker pool` 中的几个辅助线程。
- **事件循环**是一种机制，它采用回调（函数）并注册它们，准备在将来的某个时刻执行。它与相关的 JavaScript 代码在同一个线程中运行。当 JavaScript 操作阻塞线程时，事件循环也会被阻止。
- **工作池**是一种执行模型，它产生并处理单独的线程，然后同步执行任务，并将结果返回到事件循环。事件循环使用返回的结果执行提供的回调。
- 简而言之，它负责异步 `I/O` 操作 —— 主要是与系统磁盘和网络的交互。它主要由诸如 `fs`（`I/O` 密集）或 `crypto`（CPU 密集）等模块使用。工作池用 `libuv` 实现，当 `Node` 需要在 JavaScript 和 C++ 之间进行内部通信时，会导致轻微的延迟，但这几乎不可察觉。

**参考**：<a src = "https://segmentfault.com/a/1190000021462627">一文搞懂 Node.js 中的多线程和多进程</a>