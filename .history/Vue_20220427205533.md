# webpack

## 文件监听与热更新
### 热更新
- 模块热替换会在程序运行中，替换、添加、删除模块，无需重新加载整个页面，无需更替所有模块。模块热替换是`webpack`提供的最有用的功能之一，它允许在运行时更新各个模块，从而无需进行完全刷新，`hotmoudlereplacementplugin`内置插件配置 
- 与`watch`相比，它不输出文件，直接方式内存中，所以它的构建熟读更快。
- 热更新的核心是HMR Server和HMR Runtime。
  - HMR Server：是服务端，用来将变化的js模块通过websocket的消息通知给浏览器端
  - HMR Runtime：是浏览器端，用于接收HMR Server传递过来的模块数据，浏览器端可以看到.hot-update.json文件
###文件监听
- 每次修改代码后，都需要手动构建，影响开发效率。`webpack`提供了文件监听的作用。开启监听时，`webpack`会调用`node`中`fs`模块来判断文件是否发生变化，如果发生了变化，自动重新构建输出新的文件。
- `webpack`文件监听判断依据是看文件的最后编辑时间是否发生变化。

## 构建工具
- 构建工具的作用就是将这些浏览器不能识别的语法（高级语法）转换成了浏览器能识别的语法（低级语法）。
- 还有一个作用是将代码压缩混淆，在压缩代码体积的同时也让代码不易阅读。

## 核心概念
- `entry`：有两种方式：单入口、多入口
- `output`：
  - `entry`是单入口，`output`可通过修改参数`path`和`filename`。
  - `entry`是多入口，`output`的`filename`需要用`[name]`占位符，用来指定打包后的名称，对应的是`entry`中的`key`
- `mode`：可设置为`development`、`production`、`none`，默认是`production`。
  - `development`：开发环境
  - `production`：生产环境
  - `none`：不开启任何优化选项
- `loaders`
  - `webpack`只支持`js`和`json`两种文件类型，`loader`的作用就是用来处理其他的文件，并将它们添加到依赖图中。
  - `loader`是个函数，接收源文件作为参数，返回转换后的结果。
- `plugins`
  - 任何loader没法做的事情，都可以用plugin解决，它主要用于文件优化、资源管理、环境变量注入，作用于整个构建过程。
  - `plugin`是一个具有`apply`方法的`JavaScript`对象，由于`plugin`可以携带参数，所以必须在配置中向`plugins`属性传入一个实例
  
# 生命周期
## 生命周期与钩子
- `Vue`的生命周期**钩子**函数：就是指在一个组件从创建到销毁的过程自动执行的函数，包含组件的变化。
![示意图](https://cn.vuejs.org/images/lifecycle.png)
- **四个阶段**：
  - **创建阶段**: 
    - `beforeCreate`在实例初始化之后、进行数据侦听和事件/侦听器的配置之前同步调用
    - `created`在实例创建完成后被立即同步调用;
  - **挂载阶段**:
    - `beforeMount`在挂载开始之前被调用：相关的`render`函数首次被调用
    - `mounted`在挂载开始之前被调用：相关的`render`函数首次被调用;
  - **更新阶段**：
    - `beforeUpdate`在挂载开始之前被调用：相关的 `render`函数首次被调用
    - `updated`在挂载开始之前被调用：相关的 `render`函数首次被调用;
  - **销毁(卸载)阶段**:   
    - `beforeDestroy`/`beforeUnmount`在卸载组件实例之前调用,在这个阶段，实例仍然是完全正常的,
    - `destroyed`/`unmounted`卸载组件实例后调用,调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载.

# 基本概念
## 双向绑定
### 原理
![双向绑定原理](https://uploadfiles.nowcoder.com/images/20210401/447785786_1617244044166/C21B5ECC8B63BE4DC27B38A70C75A1CB)
- `View`的变化能实时让`Model`发生变化，而`Model`的变化也能实时更新`View`。
- Vue数据双向绑定原理是通过**数据劫持结合发布者-订阅者模式**的方式来实现的，首先是通过ES5提供的**Object.defineProperty()**方法来劫持（监听）各属性的`getter`、`setter`，并在当监听的属性发生变动时通知订阅者，是否需要更新，若更新就会执行对应的更新函数。
TODO: 待更新--<a src = "https://blog.nowcoder.net/n/8517450fe4fd4220b4078f9c61e42ec1">双向绑定原理</a>

## TODO: 路由

## 组件间通信
- **方法一** `props` / `$emit`
  - 父组件通过`props`向下传递数据给子组件
  - 子组件通过`events`给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。
- **方法二** `$emit` / `$on`
  - 这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件, 巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。
  - `$on` 监听了自定义事件 `data-a` 和 `data-b`，因为有时不确定何时会触发事件，一般会在 `mounted` 或 `created` 钩子中来监听
- **方法三** `vuex`
  - `Vuex`实现了一个**单向数据流**，在全局拥有一个`State`存放数据，当组件要更改`State`中的数据时，必须通过`Mutation`进行，`Mutation`同时提供了**订阅者模式**供外部插件调用获取`State`数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走`Action`，但`Action`也是无法直接修改`State`的，还是需要通过Mutation来修改State的数据。最后，根据`State`的变化，渲染到视图上。
- **方法四** `$attrs` / `$listeners`
  - `$attrs`：包含了父作用域中不被 `prop` 所识别 (且获取) 的特性绑定 (`class` 和 `style` 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (`class` 和 `style` 除外)，并且可以通过 `v-bind="$attrs"` 传入内部组件。通常配合 `interitAttrs` 选项一起使用。
  - `$listeners`：包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件
- **方法五** `provide` / `inject`
  - 允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效
  - `provide` / `inject` API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种**主动提供**与**依赖注入**的关系
- **方法六** `$parent` / `$children` 与 `ref`
  - `ref`：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组
  - `$parent` / `$children` ：访问父 / 子实例

## Vue特点
- **轻量级** Angular的学习成本高，使用起来比较复杂，而Vue相对简单、直接，所以Vue使用起来更加友好。
- **数据绑定** Vue是一个MVVM框架，数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化，这也算是Vue的精髓之处。尤其是在进行表单处理时，Vue的双向数据绑定非常方便
- **指令** 指令主要包括内置指令和自定义指令，以“v-”开头，作用于HTML元素。指令提供了一些特殊的特性， 将指令绑定在元素上时，指令会给绑定的元素添加一些特殊的行为。 例如，v-bind动态绑定指令、v-if 条件渲染指令、v- for列表渲染指令等
- **插件** 插件用于对Vue框架功能进行扩展，通过`MyPlugin.install`完成插件的编写，简单配置后就可以全局使用。常用的扩展插件有`vue-router`、`Vuex` 等
- Vue很多特性与Angular和React有着相同的地方，但是也有着性能方面的差别。
  - Vue使用基于依赖追踪的观察系统并且使用异步队列更新，所有的数据都是独立触发的，提高了数据处理能力。
  - React和Vue的中心思想是一切都是组件，组件之间可以实现嵌套。
  - React 采用了特殊的JSX语法，Vue中也推崇编写以*.vue后缀命名的文件格式，对文件内容都有一些规定，两者需要编译后使用。
  - 值得一提的是，React依赖虚拟DOM，而Vue使用的是DOM模板。Vue 在模板中提供了指令、过滤器等，可以非常方便和快捷地操作DOM。推荐将Vue 使用到具有复杂交互逻辑的前端应用中，以确保用户的体验效果。

## 双向绑定原理
- Vue数据双向绑定原理是通过数据劫持结合发布者-订阅者模式的方式来实现的，首先是对数据进行监听，然后当监听的属性发生变化时则告诉订阅者是否要更新，若更新就会执行对应的更新函数从而更新视图
- 实现数据的双向绑定，首先要对数据进行劫持监听，需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。
- 步骤
  - 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
  - 实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。
  - 实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。

# Vue3
## 性能提升
### 响应式系统提升