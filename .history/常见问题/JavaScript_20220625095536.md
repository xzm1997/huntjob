# 常用概念
## var let const
- var
  - 在全局作用域中或还是在局部作用域中，使用var关键字声明的变量，都会被提升到该作用域的最顶部，这就是我们常说的变量提升。
  - 在全局作用域声明的变量会挂载在window对象上
- let
  - 和var声明用法是一样，都是定义变量，使用let声明的变量没有var那样的变量提升，let声明的变量只在当前作用域中有效。
  - 禁止重复声明
- const
  - 常量，常量就是一旦定义完就不能修改的值。
  - 常量定义必须初始化值，如果不初始化值就会报错。
  - 不能修改指针，但是可以修改值，可改变属性
## set与map
## `===`和`==`
- `==` 
  - 会先将两边的值进行强制类型转换再比较是否相等
  - 只要求比较两个值是否相等
- `===`
  - 不会进行类型转换
  - 操作符不仅要求值相等，而且要求类型相同

## 变量的隐式转换
- `+`: `+`操作符的两边有至少一个`string`类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。
- `==`: 操作符两边的值都尽量转成`number`
- `<` 与 `>`：如果两边都是字符串，则比较字母表顺序；其他情况下，转换为数字再比较
- 对象会被`ToPrimitive`转换为基本类型再进行转换

## 页面生成过程
- HTML 被 HTML 解析器解析成 DOM 树；
- CSS  被 CSS 解析器解析成 CSSOM 树；
- 结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；
- 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
- 将布局绘制(paint)在屏幕上，显示出整个页面。

## 重绘与重排
- 重绘：某些元素的外观被改变，例如：元素的填充颜色
- 重排：重新生成布局，重新排列元素。
- 重绘不一定导致重排，但重排一定会导致重绘。单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。
### 重排
- 当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。
- 简单的说就是重新生成布局，重新排列元素。
- 下面情况会发生重排：
  - 页面初始渲染，这是开销最大的一次重排
  - 添加/删除可见的DOM元素
  - 改变元素位置
  - 改变元素尺寸，比如边距、填充、边框、宽度和高度等
  - 改变元素内容，比如文字数量，图片大小等
  - 改变元素字体大小
  - 改变浏览器窗口尺寸，比如resize事件发生时
  - 激活CSS伪类（例如：:hover）
  - 设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow
  - 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。
### 重绘
- 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。
### 优化
- 重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。
- 减少重排范围减少重排次数
  - 样式集中改变：不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式
  - 分离读写操作：DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。
- 

## Canvas 与 SVG
### Canvas
- `<canvas>` 是一个可以使用脚本(通常为JavaScript)来绘制图形的 HTML 元素。
- `<canvas>` 看起来和 `<img>` 元素很相像，唯一的不同就是它并没有 src 和 alt 属性，以及需要结束标签
- canvas是一块画布，可以在网页中绘制图像
### SVG
- SVG 与 Flash 类似，都是用于二维矢量图形，二者的区别在于，SVG 是一个 W3C 标准，基于 XML，是开放的。因为是 W3C 标准，SVG 与其他的 W3C 标准，比如 CSS、DOM 和 SMIL 等能够协同工作。
- SVG是 `W3C XML` 的分支语言之一，用于标记可缩放的矢量图形。
- 优点
  - 快速，熟悉的图像语法与alt属性中提供的内置文本等效。
  - 可以通过在`<a>`元素嵌套`<img>`，使图像轻松地成为超链接。
- 缺点
  - 无法使用JavaScript操作图像。
  - 如果要使用CSS控制SVG内容，则必须在SVG代码中包含内联CSS样式。（从SVG文件调用的外部样式表不起作用）
  - 不能用CSS伪类来重设图像样式（如:focus）。
### canvas和svg的区别
- canvas绘画出来的图形一般成为位图，也就是放大缩小的情况下会出现失真的情况，svg绘制的图形是矢量图，不存在失真的情况
- canvas绘制的图形不会出现在DOM结构中，svg绘制的会存在于DOM结构
- canvas类似于动画，每次图形的改变都是先清除原来的图形，然后把新的图形画上去，svg则是可以直接通过js来进行某些操作
- canvas依赖于分辨率，svg不依赖分辨率
- canvas最适合图像密集型的游戏，其中的许多对象会被频繁重绘，svg不适合游戏应用

# 对象
## this
### 概述
- this是JavaScript的关键字之一。它是对象自动生成的一个内部对象，只能在对象内部使用。随着函数使用场合的不同，this的值会发生变化。
- this指向什么，完全取决于什么地方以什么方式调用，而不是创建时
### 绑定规则
- 默认绑定：一般是window上，严格模式下是undefined。
- 隐性绑定：有了上下文对象后，函数里的this默认绑定为上下文对象
- 显性绑定
  - call apply bind
  - 改变函数的this指向，第一个参数都是设置this对象。
- 区别：
  - call从第二个参数开始所有的参数都是原函数的参数。
  - apply只接受两个参数，且第二个参数必须是数组，这个数组代表原函数的参数列表。
  - bind只有一个函数，且不会立刻执行，只是将一个值绑定到函数的this上,并将绑定好的函数返回
- new 绑定
  - 创建一个新对象。
  - 把这个新对象的__proto__属性指向 原函数的prototype属性。(即继承原函数的原型)
  - 将这个新对象绑定到此函数的this上。
  - 返回新对象，如果这个函数没有返回其他对象。
## Object.create()、new Object()和{}的区别
- new Object()：创建一个空对象、obj的__proto__指向构造函数Object的prototype、把构造函数Object的this指向obj，并执行构造函数Object把结果赋值给result、构造函数Object的执行结果是引用类型，就把这个引用类型的对象返回给objB，构造函数Object的执行结果是值类型，就返回obj这个空对象给objB
- Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__
- 字面量和new关键字创建的对象是Object的实例，原型指向Object.prototype，继承内置对象Object
- Object.create(arg, pro)创建的对象的原型取决于arg，arg为null，新对象是空对象，没有原型，不继承任何对象；arg为指定对象，新对象的原型指向指定对象，继承指定对象

# 函数
## 闭包
- 闭包是js的一种特性，我们可以通过闭包实现**函数内外部的连接**，并且可以使得函数的局部变量始终存在于内存中。
- 匿名自执行函数还可以用于在js中模拟创建**块级作用域**，即如果使用匿名自执行函数将某些代码包裹起来可以实现块级作用域的效果，**减少全局变量的数量**，在匿名自执行函数执行结束后变量就会被内存释放掉，从而也会节省了内存。
- 闭包允许内层函数引用父函数中的变量，但该变量是最终值
- 闭包内变量要到整个闭包被清除的时候才会清除，比如局部变量要等到函数执行完之后。
- 闭包是指有权访问另一个函数作用域中变量的函数；
## `generator`的原理 
- TODO: 待完善
- 生成器从本质上来说，是一种特殊的迭代器
## 箭头函数和一般函数的区别
- ES6中允许使用箭头`=>`来定义箭头函数
- 区别
  - 语法更加简洁、清晰
  - 箭头函数不会创建自己的this
  - 箭头函数继承而来的this指向永远不变
  - .call()/.apply()/.bind()无法改变箭头函数中this的指向
  - 箭头函数不能作为构造函数使用
  - 箭头函数没有自己的arguments
  - 箭头函数没有原型prototype
  - 箭头函数不能用作Generator函数，不能使用yeild关键字
# 异步
## promise 原型方法 静态方法
- 原型方法：`then`, `catch`, `finally`
- 静态方法：`all`, `race`, `reject`, `resolve`, `allSettled`, `any`
## promise怎么阻止它继续执行
- 在程序中，只要返回了一个 promise 对象，如果 promise 对象不是 Rejected 或 Fulfilled 状态，then 方法就会继续调用。利用这个特性，可以处理多个异步逻辑。
- 但有时候某个 then 方法的执行结果可能会决定是否需要执行下一个 then，这个时候就需中止 promise，主要思想就是使用 reject 来中止 promise 的 then 继续执行。
## async/await如果右边方法执行出错该怎么解决
- 使用`Promise.catch`捕获
- 使用 `try-catch`
## JS的深浅拷贝
- 浅拷贝
  - `Object.assign()`: 可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。
  - 函数库`lodash的_.clone`方法
  - 展开运算符`...`
  - `Array.prototype.concat()`
  - `Array.prototype.slice()`
- 深拷贝
  - 利用`JSON.stringify`将对象转成`JSON`字符串，再用`JSON.parse`把字符串解析成对象
  - 函数库`lodash的_.cloneDeep`方法
  - `jQuery.extend()`方法
  - 手写递归方法

# 事件
## 事件委托与事件捕获
- 事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。

# 原型
## 原型与原型链
- Father.prototype 就是原型，它是一个对象，我们也称它为原型对象。原型的作用，就是共享方法。原型中this的指向是实例。
- 原型与原型层层相链接的过程即为原型链。对象可以使用构造函数`prototype`原型对象的属性和方法，就是因为对象有`__proto__`原型的存在。每个对象都有`__proto__`原型的存在
- 原型查找方法
  - 首先看obj对象身上是否有dance方法，如果有，则执行对象身上的方法。
  - 如果没有dance方法，就去构造函数原型对象prototype身上去查找dance这个方法。
  - 如果再没有dance方法，就去Object原型对象prototype身上去查找dance这个方法。
  - 如果再没有，则会报错。


# 垃圾回收机制
## 垃圾回收算法
- 如C++，需要手动Delate，而java与js一类的，则可自动回收
- 回收算法
  - 标记清理
  - 引用计数
- V8的回收机制
  - 分代回收机制
  - 标记清除 & 整理
