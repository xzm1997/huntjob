# 基本概念
## 层与数据
![计算机体系结构](https://uploadfiles.nowcoder.com/images/20200623/655130036_1592902110246_6247F5A3CCCC226448FC618CFC88868E)
- **应用层**
  - 消息/报文`message`
  - `DHCP`, `DNS`, `FTP`, `Gopher`, `HTTP`, `IMAP4`, `IRC`, `NNTP`, `XMPP`, `POP3`, `SIP`, `SMTP`, `SNMP`, `SSH`, `TELNET`, `RPC`, `RTCP`, `RTSP`, `TLS`, `SDP`, `SOAP`, `GTP`, `STUN`, `NTP`, 更多
- **传输层**
  - 数据段`segment`
  - `TCP`, `UDP`, `DCCP`, `SCTP`, `RTP`, `RSVP`, `PPTP`, 更多
- **网络层**
  - 分组、数据包`packet`, `datagram`
  - `IP (IPv4`, `IPv6)`, `ARP`, `RARP`, `ICMP`, `ICMPv6`, `IGMP`, `RIP`, `OSPF`, `BGP`, `IS-IS`, `IPsec`, 更多
  - 可用`ping`检验连通
- **链路层**
  - 帧`frame`
  - `802.11`, `802.16`, `Wi-Fi`, `WiMAX`, `ATM`, `DTM`, `令牌环`, `以太网`, `FDDI`, `帧中继`, `GPRS`, `EVDO`, `HSPA`, `HDLC`, `PPP`, `L2TP`, `ISDN`, 更多
- **物理层**
  - `P-PD` `Ubit`
  - `RS-443`, `RS-232C`, `RS-485`, `理-2593`
![示意图](https://uploadfiles.nowcoder.com/images/20200628/5293318_1593316971511_DD19CE0AA900538FDAF7CBF976C32FAE)

## 层与设备
设备 | 作用于 | 层 | 备注
| :---: | :---: | :---: | :---: |
网卡|作用于|物理层
中继器|作用于|物理层|
集线器|作用于|物理层|
网桥|作用于|数据链路层|同网段:丢弃,不同网段:转发,未知网段:扩散。没有路由选择的功能。
交换机|作用于|数据链路层|
路由器|作用于|网络层|

## 常见网络协议
- `SNMP` **简单网络管理协议**。该协议能支持网络管理系统，用于监测连接到网络上的设备是否有任何引起管理者关注的情况。
- `FTP` (File Transfer Protocol) **文件传输协议**，用于Internet上的控制文件的双向传输。
- `ICMP` (Internet Control Message Protocol) **Internet控制报文协议**。用于IP主机、路由器之间传递控制消息
- `SMTP` (Simple Mail Transfer Protocal) 是**简单邮件传输协议**，是一组用于由源地址到目的地址传送邮件的规则，帮助每台计算机在发送或中转信件时找到下一个目的地。是**TCP协议**支持的应用协议。
- 接受邮件使用`POP3`
- `RTSP`(Real Time Streaming Protocol)**实时流协议**(详见音视频部分)
- `RTMP`:( **TODO:** 待补充
- **停止等待协议**(stop-and-wait)是最简单但也是最基础的**数据链路层**协议。很多有关协议的基本概念都可以从这个协议中学习到。停止等待就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。**特点**：最简单的设计，发送一帧，确认一帧。
- **`GBN`协议**：回退n帧的`ARQ`，发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么从那个发生错误的帧开始及其之后所有的帧全部再重新发送。**特点**：（GBN）复杂度低，但是不必要的帧会再重发，所以大幅度范围内使用的话效率是不高的
- **选择性重传**`ARQ`:发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么发信侧将只重新发送那个发生错误的帧。**特点**：相对于`GDN`复杂度高，但是不需要发送没必要的帧，所以效率高。
- **主要要素**
  - **语义**：语义是解释控制信息每个部分的意义.它规定了需要发出何种控制信息,以及完成的动作与做出什么样的响应
  - **语法**：语法是用户数据与控制信息的结构与格式,以及数据出现的顺序.
  - **时序**：时序是对事件发生顺序的详细说明.（也可称为“同步”）
  - 人们形象地把这三个要素描述为：语义表示要做什么,语法表示要怎么做,时序表示做的顺序.

## 拓扑结构
- **总线型**`IEEE 802.3`
  - 网络上所有的计算机都通过一条电缆相互连接起来。
  - **信号反射**和**终结器**：在总线型网络中，信号会沿着网线发送到整个网络。当信号到达线缆的端点时，将产生反射信号，这种发射信号会与后续信号发送冲突，从而使通信中断。为了防止通信中断，必须在线缆的两端安装**终结器**，以吸收端点信号，防止信号反弹。
- **星形拓朴结构**
  - 每个节点都由一个单独的通信线路连接到中心节点上。
  - 中心节点控制全网的通信，任何两台计算机之间的通信都要通过中心节点来转接。因些中心节点是网络的瓶颈，这种拓朴结构又称为集中控制式网络结构，这种拓扑结构是目前使用最普遍的拓扑结构，处于中心的网络设备跨越式集线器（Hub）也可以是交换机。
- **环形拓扑结构**
  - 环型拓扑结构是以一个共享的环型信道连接所有设备，称为**令牌环**。在环型拓扑中，信号会沿着环型信道按一个方向传播，并通过每台计算机。而且，每台计算机会对信号进行放大后，传给下一台计算机。同时，在网络中有一种特殊的信号称为令牌。令牌按顺时针方向传输。当某台计算机要发送信息时，必须先捕获令牌，再发送信息。发送信息后在释放令牌。
  - 环型结构的显著特点是每个节点用户都与两个相邻节点用户相连。
  - 工作站以**串行**方式顺序相连，形成一个**封闭**的环路结构。数据顺序通过每一工作站，直至到达数据的原发者才停止。
  - **不会有**多点冲突，每时每刻只有得到令牌的节点才能发送数据
- **树形拓扑结构**
  - 树型结构是星型结构的扩展，它由**根**结点和**分支**结点所构成
  - 对根结点的依赖性大，一旦根结点出现故障，将导致全网不能工作

## 速率与延迟
### 速率
- **比特率**(bit rate)又称传信率、信息传输速率(简称信息速率，information rate)。
- **波特率**(Baud rate)又称传码率、码元传输速率(简称码元速率)、信号传输速率(简称信号速率，signaling rate)或调制速率。
### 延迟
- **传播时延** = 传输信道长度 / 传输介质中信号的传播速率
- **传输时延** = 数据帧长度 / 发送速率
- :( **待补充**

# 硬件
## 传输介质
- **双绞线**的最大传输距离为100m。如果要加大传输距离，在两段双绞线之间可安装中继器，最多可安装4个中继器。
- **同轴电缆**的最大传输距离小于1000米
- **基带**系统使用数字信号传输

## 组成
- 从**计算机网络系统**看，计算机网络是由计算机网络的**硬件系统**和**网络软件系统**组成的；
- 从**拓补结构**看，计算机网络是由**网络节点**和**通信链路**组成的；
- 从**逻辑功能**看，计算机网络是由**用户资源子网**和**通信子网**组成的。

## IEEE 802
- `IEEE 802`又称为LMSC（LAN/MAN Standards Committee，局域网/城域网标准委员会），致力于研究局域网和城域网的物理层和`MAC`层中定义的服务和协议，对应`OSI`网络参考模型的最低两层（即物理层和数据链路层）。

标准 | 说明
| :---: | :---: |
IEEE 802.1 | 局域网体系结构、寻址、网络互联和网络。
IEEE 802.1A | 概述和系统结构。
IEEE 802.1B | 网络管理和网络互连。
IEEE 802.2 | 逻辑链路控制子层（LLC）的定义。
IEEE 802.3 | 以太网介质访问控制协议 （CSMA/CD）及物理层技术规范。
IEEE 802.4 | 令牌总线网（Token-Bus）的介质访问控制协议及物理层技术规范。
IEEE 802.5 | 令牌环网（Token-Ring)的介质访问控制协议及物理层技术规范。
IEEE 802.6 | 城域网介质访问控制协议DQDB （Distributed Queue Dual Bus 分布式队列双总线）及物理层技术规范。
IEEE 802.7 | 宽带技术咨询组，提供有关宽带联网的技术咨询。
IEEE 802.8 | 光纤技术咨询组，提供有关光纤联网的技术咨询。
IEEE 802.9 | 综合声音数据的局域网（IVD LAN）介质访问控制协议及物理层技术规范。
IEEE 802.10 | 网络安全技术咨询组，定义了网络互操作的认证和加密方法。
IEEE 802.11 | 无线局域网（WLAN）的介质访问控制协议及物理层技术规范。

## VLAN虚拟局域网
- VLAN是**虚拟局域网**，不算真正的局域网
- 虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。
- VLAN是一种比较新的技术，工作在OSI参考模型的**第2层**和**第3层**，一个VLAN就是一个**广播域**，VLAN之间的通信是通过第3层的路由器来完成的。
- 与传统的局域网技术相比较，VLAN技术更加**灵活**，它具有以下优点：网络设备的移动、添加和修改的管理**开销**减少；可以控制**广播**活动；可提高网络的**安全性**。
- 在计算机网络中，一个二层网络可以被划分为多个不同的广播域，一个广播域对应了一个特定的用户组，默认情况下这些不同的广播域是相互**隔离**的。不同的广播域之间想要**通信**，需要通过一个或多个路由器。这样的一个广播域就称为VLAN。

## 广播域与冲突域
### 冲突域
- 在以太网中，如果某个`CSMA/CD`网络(IEEE 802.3)上的两台计算机在同时通信时会发生冲突，那么这个`CSMA/CD`网络就是一个冲突域。如果以太网中的各个网段以**集线器**连接，因为不能避免冲突，所以它们仍然是一个冲突域。
- 冲突域是在同一个网络上两个比特同时进行传输则会产生冲突；在网路内部数据分组所产生与发生冲突的这样一个区域称为冲突域，所有的共享介质环境都是一个冲突域，在共享介质环境中一定类型的冲突域是正常行为。
- **集线器**与**交换机**的区别
  - **集线器**是一种**物理层**设备，本身不能识别MAC地址和IP地址，当集线器下连接的主机设备间传输数据时，数据包是以**广播**的方式进行传输，由每一台主机自己眼中MAC地址来确定是否接收。这种情况下，同一时刻由集线器连接的网络中只能传输一组数据，如果发生冲突则需要重传。集线器下连接的所有端口共享整个带宽，即所有端口为一个冲突域，如图所示。
  - **交换机**则是工作在**数据链路层**的设备，在接收到数据后，通过查找自身系统MAC地址表中的MAC地址与端口对应关系，将数据传送到目的端口。交换机在同一时刻可进行多个端口之间的数据传输，**每一端口都是独立的物理网段**，连接在端口上的网络设备独自享有全部的带宽。因此，交换机起到了**分割冲突域**的作用，每一个端口为一个冲突域
### 广播域
- **广播**是一种信息的传播方式，指网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为**广播域**
- 在传输中当不知道目的MAC地址时，需要在网段内广播当前子网下所有的节点，相应的广播报文以及目的MAC查找失败报文会向所有端口转发，因此会消耗大量的网络带宽。而二层交换机只能隔离冲突域，不能隔离广播域。
- 两个交换机相连，广播域变大，数量不变，减少了可用带宽。冲突域数量增加。

## MAC地址
- **简介**
  - `MAC`（Media Access Control，媒体访问控制）地址用来定义网络设备的位置。
  - `MAC`地址由48比特长、12位的16进制数字组成，0到23位是厂商向IETF等机构申请用来标识厂商的代码，24到47位由厂商自行分派，是各个厂商制造的所有网卡的一个唯一编号。
  - `MAC`地址可以分为3种类型：
  1. 物理`MAC`地址：
    这种类型的`MAC`地址唯一的标识了以太网上的一个终端，该地址为全球唯一的硬件地址；
  2. 广播`MAC`地址：
    全1的`MAC`地址为广播地址（`FF-FF-FF-FF-FF-FF`），用来表示`LAN`上的所有终端设备；
  3. 组播MAC地址：
    除广播地址外，第`8bit`为1的`MAC`地址为组播MAC地址（例如`01-00-00-00-00-00`），用来代表`LAN`上的一组终端。其中以`01-80-c2`开头的组播`MAC`地址叫`BPDU MAC`，一般作为协议报文的目的`MAC`地址标示某种协议报文。
- **MAC地址表**
  - 设备内有一张`MAC`地址表，简称`MAC`表。
  - `MAC`表记录了相连设备的`MAC`地址、接口号以及所属的`VLAN ID`之间的对应关系。在转发数据时，路由设备根据报文中的目的`MAC`地址和`VLAN ID`查询MAC地址表，快速定位出接口，从而减少广播。

- **基于MAC表的报文转发**
  - 设备在转发报文时，根据MAC地址表项信息，会采取以下两种转发方式：
    - **单播方式**：当MAC地址表中包含与报文目的MAC地址对应的表项时，设备直接将报文从该表项中的转发出接口发送。
    - **广播方式**：当设备收到的报文为广播报文、组播报文或MAC地址表中没有包含对应报文目的MAC地址的表项时，设备将采取广播方式将报文向除接收接口外同一VLAN内的所有接口转发。

参考：<a src = "https://www.wlgly.net/post-43.html">交换机MAC地址基础知识详解</a>


# 计算
## 子网计算
- :( **TODO:** 待补充


# IP协议
## IP路由器功能
- 运行路由协议，设置路由表
- 监测到拥塞时，合理丢弃 IP 分组
- 根据收到的 IP 分组的目的 IP 地址，将其转发到合适的输出线路上

## TTL(生存时间(Time To Live))
- TTL(生存时间(Time To Live))是IP协议包中的一个值，它告诉网络路由器包在网络中的时间是否太长而应被丢弃。有很多原因使包在一定时间内不能被传递到目的地。
- TTL的最初设想是确定一个时间范围，超过此时间就把包丢弃。由于每个路由器都至少要把TTL域减一，TTL通常表示包在被丢弃前最多能经过的路由器个数。当记数到0时，路由器决定丢弃该包，并发送一个ICMP报文给最初的发送者。
- IPv6分组中的跳数限制域的功能IPv4分组中的TTL域的功能是一样的

## IPv6
- 对于一个完整的`IPv6`地址，需要128位，已经被分成了8个段，每个段4个字符。也就是说要完整的表示一个`IPv6`地址，需要些32个字母
- **表示方法**
  - **首选格式**
    - 首选格式的表示方法其实没有任何讲究，就是将`IPv6`中的128位，也就是共32个字符完完整整，一个不漏的全写出来。
  - **压缩表示**
    1. 将整个段4个字符全部都为0的使用双冒号`::`来表示。如果连续多个段全都为0，那么也可以同样将多个段都使用双冒号`::`来表示。如果是多个段，并不需要将双冒号写多次，只需要写一次即可。为了保证零压缩有一个不含混的解释，规定在任一地址中**只能使用一次**零压缩
    2. 表示`IPv6`地址时，允许将一个段中前部分的0省略不写，因为不影响结果。中间的0不能省略，只能省略最前面的0.
  - `IPv4`内嵌在`IPv6`中


# TCP协议
## TCP与UDP
- **用户数据报协议** UDP
  - UDP在传送数据之前不需要先建立连接，远程主机在收到UDP报文后，不需要给出任何确认。
  - 虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式
- **传输控制协议** TCP
  - TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。
  - TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。
  - TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

## TCP报文段
![TCP报文段](https://segmentfault.com/img/remote/1460000039165596)
1. **源端口和目的端口**：各占2个字节，分别写入源端口和目的端口。IP地址+端口号就可以确定一个进程地址
2. **序号/序列号**（Sequense Number, SN）：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。初始序号称为Init Sequense Number, ISN
3.  **确认号**ack：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则表明：到序号N-1为止的所有数据都已正确收到。
4.  **数据偏移**（首部长度）：它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。
5.  **保留**: 占6位，应置为0，保留为今后使用。
6. **标志位字段**: 占6比特
   - `URG`：**紧急比特**（urgent）,当`URG＝1`时，表明紧急指针字段有效,代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。
   - `ACK`：**确认比特**（Acknowledge）。只有当`ACK＝1`时确认号字段才有效,代表这个封包为确认封包。当`ACK＝0`时，确认号无效。
   - `PSH`：**推送比特**（Push function）若为1时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。
   - `RST`：**复位比特**(Reset) ,当`RST＝1`时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
   - `SYN`：**同步比特**(Synchronous)，`SYN`置为1，就表示这是一个连接请求或连接接受报文,通常带有`SYN`标志的封包表示**主动**要连接到对方的意思。
   - `FIN`：**终止比特**(Final)，用来释放一个连接。当`FIN＝1`时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。

## 功能
- 完成对数据报的**确认**、**流量控制**和**网络拥塞**
- 自动检测数据报，并提供**错误重发**的功能
- 将多条路径传送的数据报按照原来的**顺序**进行排列，并对**重复**数据进行择取
- 控制**超时重发**，自动调整超时值
- 提供**自动恢复**丢失数据的功能
- *因此，除TCP功能以外需要程序员考虑的为发送数据的格式及应用层协议*

## 三次握手与四次挥手
### 三次握手
![三次握手](https://segmentfault.com/img/remote/1460000039165594)
- **进行三次握手**的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号(Init Sequense Number, `ISN`)为后面的可靠性传输做准备。
  - `SYN`：连接请求/接收 报文段
  - `seq`：发送的第一个字节的序号
  - `ACK`：确认报文段
  - `ack`：确认号。希望收到的下一个数据的第一个字节的序号
- **刚开始**客户端处于`Closed`的状态，而服务端处于`Listen`状态
  - `CLOSED` ：没有任何连接状态
  - `LISTEN` ：侦听来自远方TCP端口的连接请求
- **第一次握手**：客户端向服务端发送一个 `SYN` 报文（`SYN = 1`），并指明客户端的初始化序列号 `ISN(x)`，即图中的 `seq = x`，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 `SYN_Send` 状态。
  - `SYN-SENT` ：在发送连接请求后等待匹配的连接请求
- **第二次握手**：服务器收到客户端的 `SYN` 报文之后，会发送 `SYN` 报文作为应答（`SYN = 1`），并且指定自己的初始化序列号 `ISN(y)`，即图中的 `seq = y`。同时会把客户端的 `ISN + 1` 作为确认号 `ack` 的值，表示已经收到了客户端发来的的 `SYN` 报文，希望收到的下一个数据的第一个字节的序号是 `x + 1`，此时服务器处于 `SYN_REVD` 的状态。
  - `SYN-RECEIVED`：在收到和发送一个连接请求后等待对连接请求的确认
- **第三次握手**：客户端收到服务器端响应的 `SYN` 报文之后，会发送一个 `ACK` 报文，也是一样把服务器的 `ISN + 1` 作为 `ack` 的值，表示已经收到了服务端发来的的 `SYN` 报文，希望收到的下一个数据的第一个字节的序号是 `y + 1`，并指明此时客户端的序列号 `seq = x + 1`（初始为 `seq = x`，所以第二个报文段要 +1），此时客户端处于 `Establised` 状态。服务器收到 `ACK` 报文之后，也处于 `Establised` 状态，至此，双方建立起了 `TCP` 连接。
  - `ESTABLISHED`：代表一个打开的连接，数据可以传送给用户
- **目的**：三次握手的目的是建立**可靠的通信信道**，三次握手最主要的目的就是双方**确认自己与对方的发送与接收是正常的**。只有经过三次握手才能确认双发的收发功能都正常，缺一不可：
  - **第一次握手**：客户端发送`SYN`报文给服务器，服务器接收该报文
    - 客户端什么都不能确认
    - 服务器确认了对方发送正常，自己接收正常
  - **第二次握手**：服务器响应`SYN`报文给客户端，客户端接收该报文
    - 客户端确认了：自己发送、接收正常，对方发送、接收正常；
    - 服务器确认了：对方发送正常，自己接收正常
  - **第三次握手**：客户端发送 `ACK` 报文给服务器
    - 客户端确认了：自己发送、接收正常，对方发送、接收正常；
    - 服务器确认了：自己发送、接收正常，对方发送、接收正常
- ISN (Initial Sequence Number) 是**固定**的吗？
    - 三次握手的其中一个重要功能是客户端和服务端交换 `ISN`(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。
    - 当一端为建立连接而发送它的 `SYN` 时，它会为连接选择一个初始序号。`ISN` 随时间而变化，因此每个连接都将具有不同的 `ISN`。如果 `ISN` 是固定的，攻击者很容易猜出后续的确认号，因此 `ISN` 是**动态生成的**。
- 三次握手过程中可以**携带数据**吗
  - **第三次**握手的时候，是可以携带数据的。但是，**第一次**、**第二次**握手绝对不可以携带数据
    假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。
  - 简单的记忆就是，请求连接/接收 即 `SYN = 1` 的时候不能携带数据.
  - 而对于**第三次**的话，此时客户端已经处于 `ESTABLISHED` 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。
- **半连接队列**
  - 服务器第一次收到客户端的 `SYN` 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。
  - 当然还有一个**全连接队列**，**完成三次握手后建立起的连接**就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。
- **`SYN` 洪泛攻击**
  - `SYN` 攻击就是 `Client` 在短时间内**伪造**大量不存在的 `IP` 地址，并向 `Server` 不断地发送 `SYN` 包，`Server` 则回复确认包，并等待 `Client` 确认，由于源地址不存在，因此 `Server` 需要不断重发直至超时，这些伪造的 `SYN` 包将长时间占用半连接队列，导致正常的 `SYN` 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。
- 如果**第三次握手丢失**了，客户端服务端会如何**处理**
  - **服务器**发送完 `SYN-ACK` 包，如果未收到客户端响应的**确认包**，也即第三次握手丢失。那么服务器就会进行**首次重传**，若等待一段时间仍未收到客户**确认**包，就进行**第二次重传**。如果重传次数**超过**系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。
  - 注意，每次重传等待的时间**不一定相同**，一般会是**指数增长**，例如间隔时间为 1s，2s，4s，8s…
### 四次挥手
![四次挥手](https://segmentfault.com/img/remote/1460000039165595)
- 建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过**四次挥手**（也有将四次挥手叫做四次握手的）。这是由于 TCP 的**半关闭**（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。客户端或服务端**均可**主动发起挥手动作。
  - `FIN` ：连接终止位
  - `seq`：发送的第一个字节的序号
  - `ACK`：确认报文段
  - `ack`：确认号。希望收到的下一个数据的第一个字节的序号
- **刚开始**双方都处于`ESTABLISHED` 状态，假设是客户端先发起关闭请求
- **第一次挥手**：
  - 客户端发送一个 `FIN` 报文（请求连接终止：`FIN = 1`），报文中会指定一个序列号 `seq = u`。并停止再发送数据，主动关闭 `TCP` 连接。此时客户端处于 `FIN_WAIT1` 状态，等待服务端的确认。
  - `FIN-WAIT-1` 等待远程`TCP`的连接中断请求，或先前的连接中断请求的确认；
- **第二次挥手**：
  - 服务端收到 `FIN` 之后，会发送 `ACK` 报文，且把客户端的序号值 `+1` 作为 `ACK` 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。
  - `CLOSE-WAIT`等待从本地用户发来的连接中断请求；
  - 此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入`FIN_WAIT2`（终止等待 2）状态，等待服务端发出的连接释放报文段。
  - `FIN-WAIT-2` 从远程TCP等待连接中断请求；
- **第三次挥手**：
  - 如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 `FIN` 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态，等待客户端的确认。
  - `LAST-ACK` 等待原来发向远程TCP的连接中断请求的确认；
- **第四次挥手**：
  - 客户端收到 `FIN` 之后，一样发送一个 `ACK` 报文作为应答（`ack = w+1`），且把服务端的序列值 `+1` 作为自己 `ACK` 报文的序号值（`seq=u+1`），此时客户端处于 `TIME_WAIT`（时间等待）状态。
  - `TIME-WAIT` 等待足够的时间以确保远程TCP接收到连接中断请求的确认；
- 🚨 **注意**
  - 这个时候由服务端到客户端的 TCP 连接并未释放掉，需要经过时间等待计时器设置的时间 `2MSL`（一个报文的来回时间） 后才会进入 `CLOSED` 状态
  - 这样做的目的是确保服务端收到自己的 `ACK` 报文。如果服务端在规定时间内没有收到客户端发来的 `ACK` 报文的话，服务端会重新发送 `FIN` 报文给客户端，客户端再次收到 `FIN` 报文之后，就知道之前的 `ACK` 报文丢失了，然后再次发送 `ACK` 报文给服务端。
  - 服务端收到 `ACK` 报文之后，就关闭连接了，处于 `CLOSED` 状态。
- **为什么要四次挥手**
  - 由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。
  - 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就**完全关闭**了TCP连接。


# HTTP协议
## Cookie、localStorage、sessionStorage
特性 | Cookie | localStorage | sessionStorage
| :---: | :---:| :---: | :---: |
数据的生命期|一般由服务器生成，可设置失效时间。如在浏览器端生成Cookie，默认是关闭浏览器后失效|除非被清除，否则永久保存|仅在当前会话下有效，关闭页面或浏览器后清除
存放数据大小|4K左右|一般为5MB|一般为5MB
与服务器端通信|每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题|仅在客户端中保存，不参与和服务器的通信|仅在客户端中保存，不参与和服务器的通信
易用性|需要程序员封装，原生接口不友好|原生接口可以接受，亦可再次封装来对Object和Array有更好的支持|原生接口可以接受，亦可再次封装来对Object和Array有更好的支持

- 都是保存在浏览器端，且同源的

## `get`与`post`
- `GET`请求的数据会附在`URL`之后（就是把数据放置在`HTTP`协议头中），以`?`分割`URL`和传输数据，参数之间以`&;`相连
- `GET`方式提交的数据最多只能是1024字节，理论上`POST`没有限制，可传较大量的数据，`IIS4`中最大为80KB，IIS5中为100KB
- 在`ASP`中，服务端获取`GET`请求参数用`Request.QueryString`，获取`POST`请求参数用`Request.Form`。
- 在`JSP`中，用`request.getParameter()`来获取，虽然`JSP`中也有`request.getQueryString()`方法，但使用起来比较麻烦
- 在`PHP`中，可以用`$_GET`和`$_POST`分别获取`GET`和`POST`中的数据，而`$_REQUEST`则可以获取`GET`和`POST`两种请求中的数据。值得注意的是，`JSP`中使用`request`和`PHP`中使用`$_REQUEST`都会有隐患
- POST的安全性要比GET的安全性高。
  - *注意：这里所说的安全性和上面`GET`提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的`Security`的含义*

# 音视频
## RTSP协议实时流协议
- `RTSP`用于在希望通讯的两端建立并控制媒体会话`session`，客户端通过发出`VCR-style`命令如`play`、`record`和`pause`等来实时控制媒体流。
- `RTSP`处理流时会根据端点间可用带宽大小，将音视频等数据切割成小分组`packet`进行传输，使得客户端在播放一个分组的同时，可以解压缓存中第二个甚至下载第三个分组。通过缓存和多码率流技术，用户将不会感觉到数据间存在停顿。
- **特点**：
  - 多服务器兼容：媒体流可来自不同服务器
  - 可协商：客户端和服务器可协商`feature`支持程度
  - `HTTP`亲和性：尽可能重用`HTTP`概念，包括认证、状态码、解析等
  - 易解析：`HTML`或`MIME`解析器均可在`RTSP`中适用
  - 易扩展：新的方法或参数甚至协议本身均可添加或定制
  - 防火墙亲和性：传输层或应用层防火墙均可被协议较好处理
  - 服务器控制：控制概念易于理解，服务器不允许向客户端传输不能被客户端关闭的流
  - 多场景适用：`RTSP`提供帧级别精度，适用于更多媒体应用场景
- 相关协议介绍
  - `RTSP`组合使用了可靠传输协议`TCP`（控制）和高效传输协议`UDP`（内容）来串流`streaming`内容给用户。它支持点播`Video-On-Demand`以及直播`Live Streaming`服务。
  - `RTSP`协议本身并不负责数据传输，通常（非必须）是通过`RTP`（Real-time Transport Protocol）配合`RTCP`（Real-time Control Protocol）完成数据流和控制命令（同步、`QOS`管理等）的传输。具体应用中，三者的关系如下图所示：
![示意图](https://upload-images.jianshu.io/upload_images/2686562-c403ed80d325caf5.png?imageMogr2/auto-orient/strip|imageView2/2/w/538/format/webp)
- RTSP方法
  - `RTSP`中并没有连接的概念，而是通过会话`Session`进行管理。每个会话有对应的会话`ID`，会话中可能可能涉及一至多个流，会话生命周期中，客户端也可能切换连接（如`TCP`）来传递`RTSP`请求。

    method | direction | object | requirement
    | :---: | :---: | :---: | :---: |
    DESCRIBE | C->S | P,S | recommended
    ANNOUNCE | C->S, S->C | P,S | optional
    GET_PARAMETER | C->S, S->C | P,S | optional
    OPTIONS | C->S, S->C | P,S | required(S->C:optional)
    PAUSE | C->S | P,S | recommended
    PLAY | C->S | P,S | required
    RECORD | C->S | P,S | optional
    REDIRECT | S->C | P,S | optional
    SETUP | C->S | S | required
    SET_PARAMETER | C->S,S->C | P,S | optional
    TEARDOWN | C->S | P,S | required
    - P: 呈现（Presentation），S:流（Stream）
  - 