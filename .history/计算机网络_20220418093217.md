# 基本概念
## 服务与协议
- **协议**是水平的，即协议是控制对等实体间通信的规则。**服务**是垂直的，即服务是下层向上层通过层间接口提供的。
- 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。
- 协议的实现保证了能够向上一层提供服务。
- OSI**层与层之间**交换数据的单位是`SDU`（服务数据单元）
- 对等层即**同一层之间**传输的为`PDU`（协议数据单元）
## 层与数据
![计算机体系结构](https://uploadfiles.nowcoder.com/images/20200623/655130036_1592902110246_6247F5A3CCCC226448FC618CFC88868E)
- **应用层**
  - 消息/报文`message`
  - `DHCP`, `DNS`, `FTP`, `Gopher`, `HTTP`, `IMAP4`, `IRC`, `NNTP`, `XMPP`, `POP3`, `SIP`, `SMTP`, `SNMP`, `SSH`, `TELNET`, `RPC`, `RTCP`, `RTSP`, `TLS`, `SDP`, `SOAP`, `GTP`, `STUN`, `NTP`, `BGP`, 更多
- **传输层**
  - 数据段`segment`
  - `TCP`, `UDP`, `DCCP`, `SCTP`, `RTP`, `RSVP`, `PPTP`, 更多
- **网络层**
  - 分组、数据包、数据报`packet`, `datagram`
  - `IP (IPv4`, `IPv6)`, `ARP`, `RARP`, `ICMP`, `ICMPv6`, `IGMP`, `RIP`, `OSPF`, `IS-IS`, `IPsec`, 更多
  - 可用`ping`检验连通
- **链路层**
  - 帧`frame`
  - `802.11`, `802.16`, `Wi-Fi`, `WiMAX`, `ATM`, `DTM`, `令牌环`, `以太网`, `FDDI`, `帧中继`, `GPRS`, `EVDO`, `HSPA`, `HDLC`, `PPP`, `L2TP`, `ISDN`, 更多
- **物理层**
  - `P-PD` `Ubit`
  - `RS-443`, `RS-232C`, `RS-485`, `理-2593`
![示意图](https://uploadfiles.nowcoder.com/images/20200628/5293318_1593316971511_DD19CE0AA900538FDAF7CBF976C32FAE)

**TCP/IP:**
名称|协议
| :---: | :---: |
数据链路层|`ARP`, `RARP`
网络层|`IP`, `ICMP`, `IGMP`
传输层|`TCP`, `UDP`, `UGP`
应用层|`Telnet`, `FTP`, `SMTP`, `SNMP`

**OSI**
名称|协议
| :---: | :---: |
物理层|EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45</br>Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS
数据链路层|Frame Relay, HDLC, PPP, IEEE 802.3/802.2 </br>FDDI, ATM,  IEEE 802.5/802.2
网络层|IP，IPX，AppleTalk DDP
传输层|TCP，UDP，SPX
会话层|RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP
表示层|TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML
应用层|FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP

## 层与设备
设备 | 作用于 | 层 | 备注
| :---: | :---: | :---: | :---: |
网卡|作用于|物理层
中继器|作用于|物理层|
集线器|作用于|物理层| 同一冲突域、广播域
网桥|作用于|数据链路层|同网段:**丢弃**</br>不同网段:**转发**</br>未知网段:**扩散**</br>不可路由选择，根据MAC地址来转发帧
交换机|作用于|数据链路层| 同一广播域、不同冲突域
路由器|作用于|网络层| 不同广播域、冲突域</br>是网络与网络之间连接的桥梁。

## 常见网络协议
- :white_check_mark: `SNMP` **简单网络管理协议**。
  - 该协议能支持网络管理系统，用于监测连接到网络上的设备是否有任何引起管理者关注的情况。`SNMP`采用UDP协议在管理端和`agent`之间传输信息。`SNMP`采用`UDP` `161`端口接收和发送请求，`162`端口接收trap，执行`SNMP`的设备缺省都必须采用这些端口。`SNMP`消息全部通过`UDP`端口`161`接收，只有`Trap`信息采用`UDP`端口`162`。
  - `SNMP`管理包括下面三个**部分**：`MIB`管理信息库; `SMI`管理信息的结构和标识（也称管理信息接口`SMI`）; `SNMP`简单网络管理协议
- :white_check_mark: `FTP` (File Transfer Protocol) **文件传输协议**，用于Internet上的控制文件的双向传输。FTP需要建立双重连接，一个控制连接，一个是数据连接。控制连接用于传输`FTP`的控制命令和服务器的回送信息(`21`控制端口)；数据连接用于数据的传输，完成文件内容的传输(`20`数据端口)；
- :white_check_mark: `ICMP` (Internet Control Message Protocol) **Internet控制报文协议**。用于IP主机、路由器之间传递控制消息。**功能**：侦测远端主机是否存在；建立及维护路由资料；重导数据传送路径；数据流量控制
- :white_check_mark: `SMTP` (Simple Mail Transfer Protocal) 是**简单邮件传输协议**，是一组用于由源地址到目的地址传送邮件的规则，帮助每台计算机在发送或中转信件时找到下一个目的地。是**TCP协议**支持的应用协议。
- :white_check_mark: 接受邮件使用`POP3`
  ![POP3与IMAP](https://uploadfiles.nowcoder.com/files/20170820/8569438_1503232738971_b90e7bec54e736d1aa30406c98504fc2d56269b7.jpg)
- :white_check_mark: `RTSP`(Real Time Streaming Protocol)**实时流协议**(详见音视频部分)
- :white_check_mark: `RTMP`(Real Time Messaging Protocol)(详见音视频部分)
- :white_check_mark: **停止等待协议**(stop-and-wait)是最简单但也是最基础的**数据链路层**协议。很多有关协议的基本概念都可以从这个协议中学习到。停止等待就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。**特点**：最简单的设计，发送一帧，确认一帧。
- :white_check_mark: **`GBN`协议**：**回退n帧**的`ARQ`，发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么从那个发生错误的帧开始及其之后所有的帧全部再重新发送。**特点**：（GBN）复杂度低，但是不必要的帧会再重发，所以大幅度范围内使用的话效率是不高的
- :white_check_mark: **选择性重传**`ARQ`:发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么发信侧将只重新发送那个发生错误的帧。**特点**：相对于`GDN`复杂度高，但是不需要发送没必要的帧，所以效率高。
- :white_check_mark: `X.25`: CCITT制定的在公用数据网上供分组型终端使用的，数据终端设备（DTE）与数据通信设备（DCE）之间的接口协议。
- :white_check_mark: **综合业务数字网**（Integrated Services Digital Network，ISDN）是一个数字电话网络国际标准，是一种典型的电路交换网络系统。
- :white_check_mark: **帧中继**（ Frame Relay）是一种用于连接计算机系统的面向分组的通信方法。它主要用在公共或专用网上的局域网互联以及广域网连接
- :white_check_mark: `TAM`（Technology Acceptance Model）**技术接受模型**, 1989年，技术接受模型是Davis1运用理性行为理论研究用户对信息系统接受时所提出的一个模型，提出技术接受模型最初的目的是对计算机广泛接受的决定性因素做一个解释说明。
- :white_check_mark: `ATM`是一种为了多种业务设计的通用的面向连接的传输模式。它适用于局域网和广域网。它具有**高速数据传输率**和**支持许多种类型**如声音、数据、传真、实时视频、CD质量音频和图像的通信。
- :white_check_mark: `Telnet`协议是`TCP/IP`协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。
- :white_check_mark: `ARP`、`RARP`协议
  - ARP是**地址解析协议**，用来解析Mac和IP地址，根据IP地址获取物理地址
  - RARP**反向地址转换协议**是局域网的物理机器从网关服务器的ARP表或者缓存上根据MAC地址请求IP地址的协议，其功能与地址解析协议相反。
- :white_check_mark: `ICMP`协议
  - ICMP协议是一个**网络层**协议
  - **功能**：确认IP包是否成功到达目标地址、通知在发送过程中IP包被丢弃的原因
  - :rocket: **参考**: 
    - <a src = "https://blog.csdn.net/baidu_37964071/article/details/80514340">ICMP协议详解</a>
    - <a src = "https://juejin.cn/post/7024393894808780831">网络诊断工具Ping详解</a>

  ![ICMP](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43ff6da78f7245da9f49fa71e8b13d0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)
- :white_check_mark: RIP是一种分布式的基于距离向量的**路由选择协议**，通过广播UDP报文来交换路由信息。用于自治系统（AS）内的路由信息的传递。RIP协议基于距离矢量算法，使用“跳数”(即`metric`)来衡量到达目标地址的路由距离。距离就是通往目的站点所需经过的链路数，取值为1~15，数值16表示无穷大。适用于中小型网络。
- :white_check_mark: OSPF是一个**内部网关协议**，不使用传输协议，如UDP或TCP，而是直接用IP包封装它的数据。
- :white_check_mark: BGP是一个**外部网关协议**，用TCP封装它的数据。
- :white_check_mark: CSMA/CA是**无线局域网标准802.11**中的协议，它在CSMA的基础上增加了冲突避免的功能。ACK帧是CSMA/CA避免冲突的机制之一，也就是说，只有当发送方收到接收方发回的ACK帧后才确认发出的数据帧已正确到达目的地。
- :bell: **主要要素**
  - **语义**：语义是解释控制信息每个部分的意义.它规定了需要发出何种控制信息,以及完成的动作与做出什么样的响应
  - **语法**：语法是用户数据与控制信息的结构与格式,以及数据出现的顺序.
  - **时序**：时序是对事件发生顺序的详细说明.（也可称为**同步**）
  - 人们形象地把这三个要素**描述**为：语义表示要做什么,语法表示要怎么做,时序表示做的顺序.
 

## 拓扑结构
- :rocket: **总线型**`IEEE 802.3`
  - 网络上所有的计算机都通过一条电缆相互连接起来。
  - **信号反射**和**终结器**：在总线型网络中，信号会沿着网线发送到整个网络。当信号到达线缆的端点时，将产生反射信号，这种发射信号会与后续信号发送冲突，从而使通信中断。为了防止通信中断，必须在线缆的两端安装**终结器**，以吸收端点信号，防止信号反弹。
- :rocket: **星形拓朴结构**
  - 每个节点都由一个单独的通信线路连接到中心节点上。
  - 中心节点控制全网的通信，任何两台计算机之间的通信都要通过中心节点来转接。因些中心节点是网络的瓶颈，这种拓朴结构又称为集中控制式网络结构，这种拓扑结构是目前使用最普遍的拓扑结构，处于中心的网络设备跨越式集线器（Hub）也可以是交换机。
- :rocket: **环形拓扑结构**
  - 环型拓扑结构是以一个共享的环型信道连接所有设备，称为**令牌环**。在环型拓扑中，信号会沿着环型信道按一个方向传播，并通过每台计算机。而且，每台计算机会对信号进行放大后，传给下一台计算机。同时，在网络中有一种特殊的信号称为令牌。令牌按顺时针方向传输。当某台计算机要发送信息时，必须先捕获令牌，再发送信息。发送信息后在释放令牌。
  - 环型结构的显著特点是每个节点用户都与两个相邻节点用户相连。
  - 工作站以**串行**方式顺序相连，形成一个**封闭**的环路结构。数据顺序通过每一工作站，直至到达数据的原发者才停止。
  - :o: **不会有**多点冲突，每时每刻只有得到令牌的节点才能发送数据
- :rocket: **树形拓扑结构**
  - 树型结构是星型结构的扩展，它由**根**结点和**分支**结点所构成
  - 对根结点的依赖性大，一旦根结点出现故障，将导致全网不能工作
![拓扑结构](https://uploadfiles.nowcoder.com/images/20190925/187007874_1569397942826_F734FCF1697CB7E27D6C2C41E6F37E30)


## 速率与延迟
### 速率
- :rocket: **比特率**(bit rate)又称传信率、信息传输速率(简称信息速率，information rate)。
- :rocket: **波特率**(Baud rate)又称传码率、码元传输速率(简称码元速率)、信号传输速率(简称信号速率，signaling rate)或调制速率。
### 延迟
- :rocket: **传播时延** = 传输信道长度 / 传输介质中信号的传播速率
- :rocket: **传输时延** = 数据帧长度 / 发送速率
- :soon: **待补充**

### 传输速率与传播速率
- **传输速率**：在单位时间内，把数据注入传输介质中的速率（单位时间把数据注入介质中的比特数，单位是`Mbit/s`或者`Gbit/s`,`Tbit/s`）
- **传播速率**：在单位时间内，信号能“跑”的距离。（单位是`km/s`）
- 铜线的传播速率 > 光纤的传播速率
- 光纤传输速率 > 铜线传输速率

# 硬件
## 传输介质
- :white_check_mark:**双绞线**的最大传输距离为100m。如果要加大传输距离，在两段双绞线之间可安装中继器，最多可安装4个中继器。双绞线可以用于传输模拟或数字信号，常用点到点连接，也可用于多点连接。
  - 屏蔽双绞线（Shielded Twisted Pair，STP）,是一种广泛用于数据传输的铜质双绞线。
  - 非屏蔽双绞线(Unshilded Twisted Pair，UTP)
- :white_check_mark:**同轴电缆**的最大传输距离小于1000米。同轴电缆有基带同轴电缆和宽带同轴电缆两种基本类型。其中，基带同轴电缆用来传输数字信号，宽带同轴电缆可以传输模拟或数字信号。同轴电缆可用于点到点连接或多点连接。
- :white_check_mark:常用的**无线介质**是无线电波和微波等。无线传输不需铺设网络传输线，而且网络终端移动方便
- :white_check_mark:**基带**系统使用数字信号传输
- :white_check_mark:**光纤**
  - `FDDI`（光纤分布数据接口）的基本结构为逆向双环。一个环为主环，另一个环为备用环。当主环上的设备失效或光缆发生故障时,通过从主环向备用环的切换可继续维持`FDDI`的正常工作。这种故障容错能力是其它网络所没有的。
  - **全光网络**，指的是网络传输和交换过程全部通过光纤实现，因为不必在其中实现电光和光电转换，因此能大大提高网速。
  - **光中继器**（光中继站）是在长距离的光纤通信系统中补偿光缆线路光信号的损耗和消除信号畸变及噪声影响的设备。

## 传输媒体
- **传输媒体**并不是物理层。传输媒体在物理层的下面。由于物理层是体系结构的第一层，因此有时称物理层为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。
- 也就是说，传输媒体不知道所传输的信号什么时候是1什么时候是0。但物理层由于规定了电气特性，因此能够识别所传送的**比特**流。

## 信号传输速率
- 信号传输速率可以用两种方式**度量**：
  - 码元速率
  - 数据传输速率
  - 一个码元可能有M个bit，此时最大码元速率等于比特率的1/M倍
  - 由奈奎斯特定理，最大码元速率B=2W，R=B/logM
- 通信信道的**噪声**分为两类：**热噪声**和**冲击噪声**。其中，热噪声引起的差错是随机差错，或随机错; 冲击噪声引起的差错是突发差错，或突发错，引起突发差错的位长称为突发长度。在通信过程中产生的传输差错，是由随机差错与突发差错共同构成的。

## 组成
- 从**计算机网络系统**看，计算机网络是由计算机网络的**硬件系统**和**网络软件系统**组成的；
- 从**拓补结构**看，计算机网络是由**网络节点**和**通信链路**组成的；
- 从**逻辑功能**看，计算机网络是由**用户资源子网**和**通信子网**组成的。

## IEEE 802
- `IEEE 802`又称为LMSC（LAN/MAN Standards Committee，局域网/城域网标准委员会），致力于研究局域网和城域网的物理层和`MAC`层中定义的服务和协议，对应`OSI`网络参考模型的最低两层（即物理层和数据链路层）。
- 局域网主要涉及物理层和数据链路层两个层次。
- `IEEE802` 这一系列标准或协议则主要只讨论数据链路层问题，属于数据链路层协议。
    标准 | 说明
    | :---: | :---: |
    IEEE 802.1 | 局域网体系结构、寻址、网络互联和网络。
    IEEE 802.1A | 概述和系统结构。
    IEEE 802.1B | 网络管理和网络互连。
    IEEE 802.2 | 逻辑链路控制子层（`LLC`）的定义。
    IEEE 802.3 | 以太网介质访问控制协议`CSMA/CD`及物理层技术规范。
    IEEE 802.4 | 令牌总线网`Token-Bus`的介质访问控制协议及物理层技术规范。
    IEEE 802.5 | 令牌环网`Token-Ring`的介质访问控制协议及物理层技术规范。
    IEEE 802.6 | 城域网介质访问控制协议`DQDB`（分布式队列双总线）及物理层技术规范。
    IEEE 802.7 | 宽带技术咨询组，提供有关宽带联网的技术咨询。
    IEEE 802.8 | 光纤技术咨询组，提供有关光纤联网的技术咨询。
    IEEE 802.9 | 综合声音数据的局域网`IVD LAN`介质访问控制协议及物理层技术规范。
    IEEE 802.10 | 网络安全技术咨询组，定义了网络互操作的认证和加密方法。
    IEEE 802.11 | 无线局域网`WLAN`的介质访问控制协议及物理层技术规范。

## VLAN虚拟局域网
- VLAN是**虚拟局域网**，不算真正的局域网
- 虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。
- VLAN是一种比较新的技术，工作在OSI参考模型的**第2层**和**第3层**，一个VLAN就是一个**广播域**，VLAN之间的通信是通过第3层的路由器来完成的。
- 与传统的局域网技术相比较，VLAN技术更加**灵活**，它具有以下优点：网络设备的移动、添加和修改的管理**开销**减少；可以控制**广播**活动；可提高网络的**安全性**。
- 在计算机网络中，一个二层网络可以被划分为多个不同的广播域，一个广播域对应了一个特定的用户组，默认情况下这些不同的广播域是相互**隔离**的。不同的广播域之间想要**通信**，需要通过一个或多个路由器。这样的一个广播域就称为VLAN。

## 广播域与冲突域
### 冲突域
- 在以太网中，如果某个`CSMA/CD`网络(IEEE 802.3)上的两台计算机在同时通信时会发生冲突，那么这个`CSMA/CD`网络就是一个冲突域。如果以太网中的各个网段以**集线器**连接，因为不能避免冲突，所以它们仍然是一个冲突域。先听后发，边听边发，冲突即停，延迟重发.
- 冲突域是在同一个网络上两个比特同时进行传输则会产生冲突；在网路内部数据分组所产生与发生冲突的这样一个区域称为冲突域，所有的共享介质环境都是一个冲突域，在共享介质环境中一定类型的冲突域是正常行为。
- **集线器**与**交换机**的区别
  - **集线器**是一种**物理层**设备，本身不能识别MAC地址和IP地址，当集线器下连接的主机设备间传输数据时，数据包是以**广播**的方式进行传输，由每一台主机自己眼中MAC地址来确定是否接收。这种情况下，同一时刻由集线器连接的网络中只能传输一组数据，如果发生冲突则需要重传。集线器下连接的所有端口共享整个带宽，即所有端口为一个冲突域，如图所示。
  - **交换机**则是工作在**数据链路层**的设备，在接收到数据后，通过查找自身系统MAC地址表中的MAC地址与端口对应关系，将数据传送到目的端口。交换机在同一时刻可进行多个端口之间的数据传输，**每一端口都是独立的物理网段**，连接在端口上的网络设备独自享有全部的带宽。因此，交换机起到了**分割冲突域**的作用，每一个端口为一个冲突域
### 广播域
- **广播**是一种信息的传播方式，指网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为**广播域**
- 在传输中当不知道目的MAC地址时，需要在网段内广播当前子网下所有的节点，相应的广播报文以及目的MAC查找失败报文会向所有端口转发，因此会消耗大量的网络带宽。而二层交换机只能隔离冲突域，不能隔离广播域。
- 两个交换机相连，广播域变大，数量不变，减少了可用带宽。冲突域数量增加。

## MAC地址
- **简介**
  - `MAC`（Media Access Control，**媒体访问控制**）地址用来定义网络设备的位置。
  - `MAC`地址由48比特长、12位的16进制数字组成，0到23位是厂商向IETF等机构申请用来标识厂商的代码，24到47位由厂商自行分派，是各个厂商制造的所有网卡的一个唯一编号。
  - `MAC`地址可以分为3种类型：
  1. 物理`MAC`地址：
    这种类型的`MAC`地址唯一的标识了以太网上的一个终端，该地址为全球唯一的硬件地址；
  2. 广播`MAC`地址：
    全1的`MAC`地址为广播地址（`FF-FF-FF-FF-FF-FF`），用来表示`LAN`上的所有终端设备；
  3. 组播MAC地址：
    除广播地址外，第`8bit`为1的`MAC`地址为组播MAC地址（例如`01-00-00-00-00-00`），用来代表`LAN`上的一组终端。其中以`01-80-c2`开头的组播`MAC`地址叫`BPDU MAC`，一般作为协议报文的目的`MAC`地址标示某种协议报文。
- **MAC地址表**
  - 设备内有一张`MAC`地址表，简称`MAC`表。
  - `MAC`表记录了相连设备的`MAC`地址、接口号以及所属的`VLAN ID`之间的对应关系。在转发数据时，路由设备根据报文中的目的`MAC`地址和`VLAN ID`查询MAC地址表，快速定位出接口，从而减少广播。

- **基于MAC表的报文转发**
  - 设备在转发报文时，根据MAC地址表项信息，会采取以下两种转发方式：
    - **单播方式**：当MAC地址表中包含与报文目的MAC地址对应的表项时，设备直接将报文从该表项中的转发出接口发送。
    - **广播方式**：当设备收到的报文为广播报文、组播报文或MAC地址表中没有包含对应报文目的MAC地址的表项时，设备将采取广播方式将报文向除接收接口外同一VLAN内的所有接口转发。

- 为什么有了`IP`，还需要`mac`地址，或者是有了`mac`，还需要`ip`呢？
  - 首先`IP`地址是网络层的组成部分，`mac`地址是数据链路层的组成部分。`IP`地址是逻辑地址，是可发生变化的。`mac`地址就是适配器（网卡）的地址，是不变的。做个比喻，`mac`地址就想我们的身份证号，`ip`地址像是邮编号，是分层的。在日常生活中，两者是不可缺少的。为什么是不可或缺的呢？这里给出一些理由：
    1. 网络层不只有`IP`协议，还有其它的协议。如果适配器只要获取`IP`地址，那么遇到不同的网络层协议，无法工作
    2. 如果适配器是`IP`地址，那么`IP`地址需要存储在适配器的`ram`中，对于一个新的网络环境，适配器都要改变其`IP`地址。
    3. 如果适配器没有地址，那么又有一个问题：对于以太网技术而言，一个主机向链路发送了数据，其它局域网的主机都会接收到。都要解析`IP`，然后和自己`IP`匹配。浪费时间。如果有`mac`，只需要比对一下`mac`就行了。

⭐**参考**：<a src = "https://www.wlgly.net/post-43.html">交换机MAC地址基础知识详解</a>
⭐**参考**：<a src = "https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ">如果让你来设计网络</a>

## 网络组织
- 小城市-端局全覆盖
- 中等城市-汇接局全覆盖
- 大城市-汇接局分区

## 交换机
- **二层交换机**：支持物理层和数据链路层协议，如以太网交换机
- **三层交换机**：支持物理层，数据链路层及网络层协议，如某些带路由功能的交换机

## 路由器
- 可以用`route`命令查看**路由表**，主要包括网络地址、子网掩码、下一跳
- 标准路由器表有4个**项目**：
  1. 目的网络`IP`地址
  2. 子网掩码
  3. 下一跳`IP`地址
  4. 接口
- **路由协议**
  - **主动路由协议**：路由器在互联网上**动态找寻**所有网络,并确保所有路由器拥 有相同路由表的协议. 它基本上就是决定数据包通过互联网最右路径的协议. `RIPv1`, `RIPv2`, `EIGRP`和`OSPF`都是主动路由协议
  - **被动路由协议**：路由器**不自动搜寻**网络，需要手工配置。一旦所有的路由器都了解了所有的网络,被动路由协议便可 用来发送用户数据(数据包)，通过互联网络被动路由协议被分派到接口上,并决定数据包的传送方式。`IP`和`IPv6`就是被动路由协议
- **默认路由**是在路由器中当没有其他路由表项时可以选择的路由表项，也称为最后的路由。

## 编码
![编码方式](https://uploadfiles.nowcoder.com/images/20200823/97676520_1598146423745_2ACE7E0DDC324F941D9408346EC00132)
- 差分曼彻斯特编码简单记忆法，**同1异0**：即下一个编码是1时与前面编码后半部分相同表示不跳变,是0时则发生跳变

## `SDN` 软件定义网络
- `SDN` 与传统网络的最大区别就在于可以通过编写软件的方式来灵活定义网络设备的转发功能。
- **特征**：
  - 网络开放可编程
  - 控制平面与数据平面分离
  - 逻辑上的集中控制
  ![SDN](https://uploadfiles.nowcoder.com/images/20210811/71362361_1628640541158/D9CD2A05DAF94874197D4B7E873FD36F)

## `NAT` 模式
- 当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用`NAT`方法。
- `NAT`不仅能**解决了lP地址不足的问题**，而且还能够有效地**避免来自网络外部的攻击**，**隐藏并保护网络内部的计算机**。
- `NAT` 的**实现方式**有三种，即**静态转换**`Static Nat`、**动态转换**`Dynamic Nat`和**端口多路复用**`OverLoad`。
  - **静态转换**是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备（如服务器）的访问。
  - **动态转换**是指将内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。
  - **端口多路复用**(Port address Translation,PAT)是指改变外出数据包的源端口并进行端口转换，即端口地址转换(PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。
- NAT配置
  - 在配置NAT(网络地址转换)之前，首先需要了解内部本地地址和内部全局地址的分配情况。根据不同的需求，执行以下不同的**配置任务**。
    - 内部源地址NAT配置
    - 内部源地址NAPT配置
    - 重叠地址NAT配置
    - TCP负载均衡
- 采用NAT时，在虚拟机中，**不用做任何配置**，只要宿主机器访问网络即可。

# 链路层
## `OFPF` 开放的最短路径优先
- `OSPF`采用的度量是带宽，单位为`10^8/带宽`
- `OSPF`用度量来表示费用、距离、时延、带宽等等。

# 计算
## 子网计算
### IP地址结构
- 二级地址与三级地址
  ![pic](https://img-blog.csdnimg.cn/2019070110121864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R5eWF5NTIx,size_16,color_FFFFFF,t_70)
- 利用**子网掩码**判断两种IP地址：子网掩码就是用来区分地址中有没有子网号的，所以都是一串01字符串来表示；**网络号和子网号用1表示，主机号用零表示**，因此ABC类地址的子网掩码是有默认的：
  ![pic](https://img-blog.csdnimg.cn/20190701101341712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R5eWF5NTIx,size_16,color_FFFFFF,t_70)
- IP地址与子网掩码**相与**，得出的就是网络地址
- **常见题**：
  1. 已知主机IP，子网掩码，求**网络地址**
    考察基本运算，将IP地址与子网掩码直接相与即可
  2. 已知某A类网络的子网掩码`255.224.0.0`，求可划分的**子网个数**，并写出子网号
    由A类网络可知默认子网掩码`255.0.0.0`，多出来的224就是子网号，即`11100000`，子网号就是占了前三个号，2的3次方，也就是八个子网个数，至于每个的子网号，就看后五位为零的主机号，去除掉全零和全一，也就是都从`00001`到`11110`的范围：
    **注意：**根据已经成为因特网标准协议的`RFC950`文档，子网号不能全为1或者全0，但是随着**无分类域间路由选择**`CIDR`的广泛使用，现在全1或者全0的子网号也可以使用了，但一定要谨慎使用。故本题答案为6 / 8。
  3. 将某C网`200.161.30.0`划分为4个子网，计算每个子网的有效的主机IP**地址范围**和对应的**子网掩码**
    四个子网就是两个1，即`11000000`，C网的默认子网掩码为 `255.255.255.0`，加上四个子网之后就是：`255.255.255.192`；
    地址范围就是11的全排列
  - **注意**：而主机号全为0表示本网络本身，主机号全为1表示本网络的广播地址，不用于源IP地址或者目的IP地址

### 子网表示
- 通过与IP地址格式相同的点分十进制表示
    ```如：255.0.0.0 或 255.255.255.128```
- 在IP地址后加上"/"符号以及`1-32`的数字
    ```
    其中1-32的数字表示子网掩码中网络标识位的长度
    如：192.168.1.1/24 的子网掩码也可以表示为 255.255.255.0
    ```


# IP协议
## IP路由器功能
- 运行路由协议，设置路由表
- 监测到拥塞时，合理丢弃 IP 分组
- 根据收到的 IP 分组的目的 IP 地址，将其转发到合适的输出线路上

## TTL(生存时间(Time To Live))
- TTL(生存时间(Time To Live))是IP协议包中的一个值，它告诉网络路由器包在网络中的时间是否太长而应被丢弃。有很多原因使包在一定时间内不能被传递到目的地。
- TTL的最初设想是确定一个时间范围，超过此时间就把包丢弃。由于每个路由器都至少要把TTL域减一，TTL通常表示包在被丢弃前最多能经过的路由器个数。当记数到0时，路由器决定丢弃该包，并发送一个ICMP报文给最初的发送者。
- IPv6分组中的跳数限制域的功能IPv4分组中的TTL域的功能是一样的

## IPv6
- 对于一个完整的`IPv6`地址，需要128位，已经被分成了8个段，每个段4个字符。也就是说要完整的表示一个`IPv6`地址，需要些32个字母
- **表示方法**
  - **首选格式**
    - 首选格式的表示方法其实没有任何讲究，就是将`IPv6`中的128位，也就是共32个字符完完整整，一个不漏的全写出来。
  - **压缩表示**
    1. 将整个段4个字符全部都为0的使用双冒号`::`来表示。如果连续多个段全都为0，那么也可以同样将多个段都使用双冒号`::`来表示。如果是多个段，并不需要将双冒号写多次，只需要写一次即可。为了保证零压缩有一个不含混的解释，规定在任一地址中**只能使用一次**零压缩
    2. 表示`IPv6`地址时，允许将一个段中前部分的0省略不写，因为不影响结果。中间的0不能省略，只能省略最前面的0.
  - `IPv4`内嵌在`IPv6`中
## IP地址
- **A类IP地址**范围从`1.0.0.0`到`126.0.0.0`。可用的A类网络有(2^7-2)126个，每个网络能容纳1亿多个主机。
- **B类IP地址**范围从`128.0.0.0`到`191.255.255.255`。可用的B类网络有(2^14-1)16382个，每个网络能容纳6万多个主机。
- **C类IP地址**范围从`192.0.0.0`到`223.255.255.255`。C类网络可达(2^21-1)209万余个，每个网络能容纳254个主机。
- **D类地址**用于多点广播（Multicast）。 D类IP地址第一个字节以`1110`开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。 
- **E类IP地址**以`11110`开始，为将来使用保留。 
- 127开头的全为**主机回旋地址**
- A、B、C类各保留了3个区域作为**私有地址**
  - 私有IP地址允许连接到同一网络的设备相互通信，而无需连接到整个互联网。通过使外部主机或用户更难以建立连接，私有IP有助于加强特定网络（例如您的家庭或办公室）内的**安全性**。
  - 地址范围如下： 
    - **A类地址**：`10.0.0.0`～`10.255.255.255`
    - **B类地址**：`172.16.0.0`～`172.31.255.255`
    - **C类地址**：`192.168.0.0`～`192.168.255.255`
  
  类别|地址范围|私有地址
  | :---: | :---: | :---: |
  A类|`1.0.0.0`～`126.0.0.0`|`10.0.0.0`～`10.255.255.255`
  B类|`128.0.0.0`～`191.255.255.255`|`172.16.0.0`～`172.31.255.255`
  C类|`192.0.0.0`～`223.255.255.255`|`192.168.0.0`～`192.168.255.255`
  D类|以`1110`开始|——
  E类|以`11110`开始|——

## IP数据报
- IP协议提供**不可靠无连接**的数据报传输服务，IP层提供的服务是通过IP层对数据报的封装与拆封来实现的。
- IP数据报的格式分为**报头区**和**数据区**两大部分，其中报头区是为了正确传输高层数据而加的各种控制信息，数据区包括高层协议需要传输的数据。
- **格式**
![数据报](https://uploadfiles.nowcoder.com/images/20190812/300975041_1565609774719_B19A5B831E96D7FB70D030DCA3F22FC3)
- 参考：<a src = "https://blog.csdn.net/wangzhen209/article/details/74453548">IP数据报格式详解</a>

## IP服务
- IP服务的三个特点为**不可靠**、**面向无连接**和**尽最大努力投递**。
- IP由IP协议控制传输的协议单元称为IP数据报。IP协议屏蔽下层各种物理网络的差异,向上层（主要是TCP层或UDP层）提供统一的IP数据报。作为一种互联网协议，运行于网络层，屏蔽各个物理网络的细节和差异，为其高层用户提供如下3种服务：
  1. **不可靠的数据投递服务**。数据报的投递没有任何品质保证，数据报可能被正确投递，也可能被丢弃；
  2. **面向无连接的传输服务**。这种方式不管数据报的传输经过哪些结点，甚至可以不管数据报起始和终止的计算机。数据报的传输可能经过不同的传输路径，而且这些数据报在传输过程中有可能丢失，也有可能正确传输到目的结点；
  3. **尽最大努力投递服务**。IP不会随意丢包，除非系统的资源耗尽、接收出现错误、或者网路出现故障的情况下，才不得不丢弃报文

## `DHCP` 动态主机配置协议
- 将客户主机`ip`地址设置为动态获取方式时，`DHCP`服务器就会根据`DHCP`协议给客户端分配`IP`，使得客户机能够利用这个`IP`上网。
- **实现**
  - **第一步**：`Client`端在局域网内发起一个`DHCP　Discover`包，目的是想发现能够给它提供`IP`的`DHCP Server`。
  - **第二步**：可用的`DHCP Server`接收到`Discover`包之后，通过发送`DHCP Offer`包给予`Client`端应答，意在告诉`Client`端它可以提供`IP`地址。
  - **第三步**：`Client`端接收到`Offer`包之后，发送`DHCP Request`包请求分配`IP`。
  - **第四步**：`DHCP Server`发送`ACK`数据包，确认信息。

# 运输层
## 功能
- 运输层的一个很重要的功能是**复用**和**分用**:
  - **复用**, 发送方不同的应用都可以使用用一个运输层协议传递数据(加上合适的首部加以区分)
  - **分用**, 接收方的运输层在剥去报文的首部后能够把数据正确的交付到目的应用.
  - 为了解决复用和分用过程中数据不混淆的问题, 运输层采用协议端口号(或端口)来区分.在TCP/IP体系中, 运输层采用16位(共65535个)的端口号来标识一个端口. 端口只是具有本地意义, 表示了应用程序和运输层交互时使用的标识.

# TCP协议
## TCP与UDP
- **用户数据报协议** UDP
  - UDP在传送数据之前不需要先建立连接，远程主机在收到UDP报文后，不需要给出任何确认。
  - 虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式
- **传输控制协议** TCP
  - TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。
  - TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。
  - TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

## TCP报文段
![TCP报文段](https://segmentfault.com/img/remote/1460000039165596)
1. **源端口和目的端口**：各占2个字节，分别写入源端口和目的端口。IP地址+端口号就可以确定一个进程地址
2. **序号/序列号**（Sequense Number, SN）：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。初始序号称为Init Sequense Number, `ISN`
3.  **确认号**ack：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则表明：到序号N-1为止的所有数据都已正确收到。
4.  **数据偏移**（首部长度）：它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。
5.  **保留**: 占6位，应置为0，保留为今后使用。
6. **标志位字段**: 占6比特
   - `URG`：**紧急比特**（urgent）,当`URG＝1`时，表明紧急指针字段有效,代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。
   - `ACK`：**确认比特**（Acknowledge）。只有当`ACK＝1`时确认号字段才有效,代表这个封包为确认封包。当`ACK＝0`时，确认号无效。
   - `PSH`：**推送比特**（Push function）若为1时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。
   - `RST`：**复位比特**(Reset) ,当`RST＝1`时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
   - `SYN`：**同步比特**(Synchronous)，`SYN`置为1，就表示这是一个连接请求或连接接受报文,通常带有`SYN`标志的封包表示**主动**要连接到对方的意思。
   - `FIN`：**终止比特**(Final)，用来释放一个连接。当`FIN＝1`时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。
 - TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。

## 功能
- 完成对数据报的**确认**、**流量控制**和**网络拥塞**
- 自动检测数据报，并提供**错误重发**的功能
- 将多条路径传送的数据报按照原来的**顺序**进行排列，并对**重复**数据进行择取
- 控制**超时重发**，自动调整超时值
- 提供**自动恢复**丢失数据的功能
- *因此，除TCP功能以外需要程序员考虑的为发送数据的格式及应用层协议*

## 三次握手与四次挥手
### 三次握手
![三次握手](https://segmentfault.com/img/remote/1460000039165594)
- **进行三次握手**的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号(Init Sequense Number, `ISN`)为后面的可靠性传输做准备。
  - `SYN`：连接请求/接收 报文段
  - `seq`：发送的第一个字节的序号
  - `ACK`：确认报文段
  - `ack`：确认号。希望收到的下一个数据的第一个字节的序号
- **刚开始**客户端处于`Closed`的状态，而服务端处于`Listen`状态
  - `CLOSED` ：没有任何连接状态
  - `LISTEN` ：侦听来自远方TCP端口的连接请求
- **第一次握手**：客户端向服务端发送一个 `SYN` 报文（`SYN = 1`），并指明客户端的初始化序列号 `ISN(x)`，即图中的 `seq = x`，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 `SYN_Send` 状态。
  - `SYN-SENT` ：在发送连接请求后等待匹配的连接请求
- **第二次握手**：服务器收到客户端的 `SYN` 报文之后，会发送 `SYN` 报文作为应答（`SYN = 1`），并且指定自己的初始化序列号 `ISN(y)`，即图中的 `seq = y`。同时会把客户端的 `ISN + 1` 作为确认号 `ack` 的值，表示已经收到了客户端发来的的 `SYN` 报文，希望收到的下一个数据的第一个字节的序号是 `x + 1`，此时服务器处于 `SYN_REVD` 的状态。
  - `SYN-RECEIVED`：在收到和发送一个连接请求后等待对连接请求的确认
- **第三次握手**：客户端收到服务器端响应的 `SYN` 报文之后，会发送一个 `ACK` 报文，也是一样把服务器的 `ISN + 1` 作为 `ack` 的值，表示已经收到了服务端发来的的 `SYN` 报文，希望收到的下一个数据的第一个字节的序号是 `y + 1`，并指明此时客户端的序列号 `seq = x + 1`（初始为 `seq = x`，所以第二个报文段要 +1），此时客户端处于 `Establised` 状态。服务器收到 `ACK` 报文之后，也处于 `Establised` 状态，至此，双方建立起了 `TCP` 连接。
  - `ESTABLISHED`：代表一个打开的连接，数据可以传送给用户
- **目的**：三次握手的目的是建立**可靠的通信信道**，三次握手最主要的目的就是双方**确认自己与对方的发送与接收是正常的**。只有经过三次握手才能确认双发的收发功能都正常，缺一不可：
  - **第一次握手**：客户端发送`SYN`报文给服务器，服务器接收该报文
    - 客户端什么都不能确认
    - 服务器确认了对方发送正常，自己接收正常
  - **第二次握手**：服务器响应`SYN`报文给客户端，客户端接收该报文
    - 客户端确认了：自己发送、接收正常，对方发送、接收正常；
    - 服务器确认了：对方发送正常，自己接收正常
  - **第三次握手**：客户端发送 `ACK` 报文给服务器
    - 客户端确认了：自己发送、接收正常，对方发送、接收正常；
    - 服务器确认了：自己发送、接收正常，对方发送、接收正常
- ISN (Initial Sequence Number) 是**固定**的吗？
    - 三次握手的其中一个重要功能是客户端和服务端交换 `ISN`(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。
    - 当一端为建立连接而发送它的 `SYN` 时，它会为连接选择一个初始序号。`ISN` 随时间而变化，因此每个连接都将具有不同的 `ISN`。如果 `ISN` 是固定的，攻击者很容易猜出后续的确认号，因此 `ISN` 是**动态生成的**。
- 三次握手过程中可以**携带数据**吗
  - **第三次**握手的时候，是可以携带数据的。但是，**第一次**、**第二次**握手绝对不可以携带数据
    假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。
  - 简单的记忆就是，请求连接/接收 即 `SYN = 1` 的时候不能携带数据.
  - 而对于**第三次**的话，此时客户端已经处于 `ESTABLISHED` 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。
- **半连接队列**
  - 服务器第一次收到客户端的 `SYN` 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。
  - 当然还有一个**全连接队列**，**完成三次握手后建立起的连接**就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。
- **`SYN` 洪泛攻击**
  - `SYN` 攻击就是 `Client` 在短时间内**伪造**大量不存在的 `IP` 地址，并向 `Server` 不断地发送 `SYN` 包，`Server` 则回复确认包，并等待 `Client` 确认，由于源地址不存在，因此 `Server` 需要不断重发直至超时，这些伪造的 `SYN` 包将长时间占用半连接队列，导致正常的 `SYN` 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。
- 如果**第三次握手丢失**了，客户端服务端会如何**处理**
  - **服务器**发送完 `SYN-ACK` 包，如果未收到客户端响应的**确认包**，也即第三次握手丢失。那么服务器就会进行**首次重传**，若等待一段时间仍未收到客户**确认**包，就进行**第二次重传**。如果重传次数**超过**系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。
  - 注意，每次重传等待的时间**不一定相同**，一般会是**指数增长**，例如间隔时间为 1s，2s，4s，8s…

### 四次挥手
![四次挥手](https://segmentfault.com/img/remote/1460000039165595)
- 建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过**四次挥手**（也有将四次挥手叫做四次握手的）。这是由于 TCP 的**半关闭**（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。客户端或服务端**均可**主动发起挥手动作。
  - `FIN` ：连接终止位
  - `seq`：发送的第一个字节的序号
  - `ACK`：确认报文段
  - `ack`：确认号。希望收到的下一个数据的第一个字节的序号
- **刚开始**双方都处于`ESTABLISHED` 状态，假设是客户端先发起关闭请求
- **第一次挥手**：
  - 客户端发送一个 `FIN` 报文（请求连接终止：`FIN = 1`），报文中会指定一个序列号 `seq = u`。并停止再发送数据，主动关闭 `TCP` 连接。此时客户端处于 `FIN_WAIT1` 状态，等待服务端的确认。
  - `FIN-WAIT-1` 等待远程`TCP`的连接中断请求，或先前的连接中断请求的确认；
- **第二次挥手**：
  - 服务端收到 `FIN` 之后，会发送 `ACK` 报文，且把客户端的序号值 `+1` 作为 `ACK` 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。
  - `CLOSE-WAIT`等待从本地用户发来的连接中断请求；
  - 此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入`FIN_WAIT2`（终止等待 2）状态，等待服务端发出的连接释放报文段。
  - `FIN-WAIT-2` 从远程TCP等待连接中断请求；
- **第三次挥手**：
  - 如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 `FIN` 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态，等待客户端的确认。
  - `LAST-ACK` 等待原来发向远程TCP的连接中断请求的确认；
- **第四次挥手**：
  - 客户端收到 `FIN` 之后，一样发送一个 `ACK` 报文作为应答（`ack = w+1`），且把服务端的序列值 `+1` 作为自己 `ACK` 报文的序号值（`seq=u+1`），此时客户端处于 `TIME_WAIT`（时间等待）状态。
  - `TIME-WAIT` 等待足够的时间以确保远程TCP接收到连接中断请求的确认；
- 🚨 **注意**
  - 这个时候由服务端到客户端的 TCP 连接并未释放掉，需要经过时间等待计时器设置的时间 `2MSL`（MSL是TCP报文里面**最大生存时间**，它是任何报文段被丢弃前在网络内的最长时间。） 后才会进入 `CLOSED` 状态
  - 这样做的目的是确保服务端收到自己的 `ACK` 报文。如果服务端在规定时间内没有收到客户端发来的 `ACK` 报文的话，服务端会重新发送 `FIN` 报文给客户端，客户端再次收到 `FIN` 报文之后，就知道之前的 `ACK` 报文丢失了，然后再次发送 `ACK` 报文给服务端。
  - 服务端收到 `ACK` 报文之后，就关闭连接了，处于 `CLOSED` 状态。
- **为什么要四次挥手**
  - 由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。
  - 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就**完全关闭**了TCP连接。

## 流量控制
- TCP通过**滑动窗口**的概念来进行流量控制。滑动窗口，可以理解成接收端所能提供的**缓冲区**大小。
- TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓冲区。由于窗口由`16bit`所定义，所以接收端`TCP`能最大提供65535个字节的缓冲。由此，可以利用窗口大小和第一个数据的序列号计算出最大可接收的数据序列号。 
- 滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。 
- **滑动窗口协议**:
  - **窗口合拢**：当窗口从左边向右边靠近的时候，这种现象发生在数据被**发送**和**确认**的时候。   
  - **窗口张开**：当窗口的右边沿向右边移动的时候，这种现象发生在接受端**处理**了数据以后。 
  - **窗口收缩**：当窗口的右边沿向左边移动的时候，这种现象**不常发生**。 
- `cwnd`是拥塞控制窗口，`rwnd`是流量控制窗口。

# HTTP协议
## HTTP :two:
### HTTP/0.9
- 只有一个请求行，并没有HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。
- 服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。
- 返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。
### HTTP1.X
-  HTTP/1.0 引入了请求头和响应头。在支持多种类型文件下载的基础之上，HTTP/1.0 还提供了 Cache 机制、用户代理、状态码等一些基础信息。
-  HTTP/1.1 增加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率（不过由于各种原因，管线化技术最终被各大厂商放弃了）。
-  除此之外，HTTP/1.1 还引入了 Cookie、虚拟主机的支持、对动态内容的支持等特性。
-  HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：
   - 增加了持久连接；
   - 浏览器为每个域名最多同时维护 6 个 TCP 持久连接；
   - 使用 CDN 的实现域名分片机制。
### HTTP2.0
- 带来20%-60%的性能提升
- HTTP/1.1 的**问题**：很难将带宽用满。原因：
  - TCP 的慢启动
  - 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。
  - HTTP/1.1 队头阻塞的问题：在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着不能随意在一个管道中发送请求和接收内容。
- HTTP/2 的多路复用：**一个域名只使用一个 TCP 长连接和消除队头阻塞问题**
  - HTTP/2 的思路就是一个域名**只使用一个 TCP 长连接**来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。
  - 队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的**并行请求**，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。
- HTTP/2 **其他特性**
  - 可以设置请求的优先级
  - 服务器推送
  - 头部压缩
### HTTP3.0
- HTTP2.0 的缺陷
  - TCP 的队头阻塞
    - 队头阻塞：TCP 传输过程中，由于单个数据包的丢失而造成的阻塞
    - 多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。随着**丢包率**的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。

## Cookie、localStorage、sessionStorage
特性 | Cookie | localStorage | sessionStorage
| :---: | :---:| :---: | :---: |
数据的生命期|一般由服务器生成，可设置失效时间。如在浏览器端生成`Cookie`，默认是关闭浏览器后失效|除非被清除，否则永久保存|仅在当前会话下有效，关闭页面或浏览器后清除
存放数据大小|4K左右|一般为5MB|一般为5MB
与服务器端通信|每次都会携带在`HTTP`头中，如果使用`cookie`保存过多数据会带来性能问题|仅在客户端中保存，不参与和服务器的通信|仅在客户端中保存，不参与和服务器的通信
易用性|需要程序员封装，原生接口不友好|原生接口可以接受，亦可再次封装来对`Object`和`Array`有更好的支持|原生接口可以接受，亦可再次封装来对`Object`和`Array`有更好的支持

- 都是保存在浏览器端，且**同源**的
### Cookie
- `Session`是在服务端保存的一个数据结构，用来**跟踪**用户的状态，这个数据可以保存在集群、数据库、文件中
- `Cookie`是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现`Session`的一种方式。
- 当浏览器访问服务器时，服务器会创建一个`session`对象，该对象有一个唯一的`id`号，称之为`sessionId`。服务器在默认的情况下，会将`sessionId`以`cookie`的方式，发送给浏览器，浏览器会将`sessionId`保存到内存中。当浏览器再次访问服务器时，会将`sessionId`发送给服务器，服务器依据`sessionId`就可以找到之间创建的`session`对象。
- `session` 与 `cookie` **差别**
  1. `session` 在服务器端，`cookie` 在客户端（浏览器）
  2. `session` 默认被存在在服务器的一个文件里（不是内存）
  3. `session` 的运行依赖 `session id`，而 `session id` 是存在 `cookie` 中的，也就是说，如果浏览器禁用了 cookie ，同时 `session` 也会失效（但是可以通过其它方式实现，比如在 `url` 中传递 `session_id`）
  4. `session` 可以放在文件、数据库、或内存中都可以。
  5. 用户验证这种场合一般会用 `session`



## http方法
- `GET`请求的数据会附在`URL`之后（就是把数据放置在`HTTP`协议头中），以`?`分割`URL`和传输数据，参数之间以`&;`相连
- `GET`方式提交的数据最多只能是1024字节，理论上`POST`没有限制，可传较大量的数据，`IIS4`中最大为80KB，IIS5中为100KB
- 在`ASP`中，服务端获取`GET`请求参数用`Request.QueryString`，获取`POST`请求参数用`Request.Form`。
- 在`JSP`中，用`request.getParameter()`来获取，虽然`JSP`中也有`request.getQueryString()`方法，但使用起来比较麻烦
- 在`PHP`中，可以用`$_GET`和`$_POST`分别获取`GET`和`POST`中的数据，而`$_REQUEST`则可以获取`GET`和`POST`两种请求中的数据。值得注意的是，`JSP`中使用`request`和`PHP`中使用`$_REQUEST`都会有隐患
- POST的安全性要比GET的安全性高。
  - *注意：这里所说的安全性和上面`GET`提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的`SecURLty`的含义*
- HTTP `PUT`请求方法使用请求中的**负载创建或者替换目标资源**。
- `PUT` 与 `POST` 方法的区别在于，`PUT`方法是**幂等**的：调用一次与连续调用多次是等价的（即没有副作用），而连续调用多次`POST`方法可能会有副作用，比如将一个订单重复提交多次。
- `OPTIONS`: 询问可以执行哪些方法
- `TRACE`: 用于远程诊断服务器
- `HEAD`: 类似于`GET`, 但是不返回`body`信息，用于**检查对象是否存在**，以及得到对象的元数据
-  `HEAD`, `GET`, `OPTIONS`和`TRACE`视为**安全**的方法，因为它们只是从服务器获得资源而不对服务器做任何修改
- 但是`HEAD`, `GET`, `OPTIONS`**在用户端不安全**。而`POST`则影响**服务器**上的资源。

## HTTP状态码
- 常用
  - 当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求。
  - 200 - 请求成功
  - 301 - 资源（网页等）被永久转移到其它`URL`
  - 404 - 请求的资源（网页等）不存在
  - 500 - 内部服务器错误
- 分类
    分类 | 分类描述
    | :---: | :---: |
    1** | 信息，服务器收到请求，需要请求者继续执行操作
    2** | 成功，操作被成功接收并处理
    3** | 重定向，需要进一步的操作以完成请求
    4** | 客户端错误，请求包含语法错误或无法完成请求
    5** | 服务器错误，服务器在处理请求的过程中发生了错误
- 状态码列表
    状态码 | 状态码英文名称 | 中文描述
    | :---: | :---: | :---: |
    100 | Continue | **继续**。客户端应继续其请求
    101 | Switching Protocols | **切换协议**。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议
    200 | OK | **请求成功**。一般用于GET与POST请求
    201 | Created | **已创建**。成功请求并创建了新的资源
    202 | Accepted | **已接受**。已经接受请求，但未处理完成
    203 | Non-Authoritative Information | **非授权信息**。请求成功。但返回的meta信息不在原始的服务器，而是一个副本
    204 | No Content | **无内容**。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
    205 | Reset Content | **重置内容**。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域
    206 | Partial Content | **部分内容**。服务器成功处理了部分GET请求
    300 | Multiple Choices | **多种选择**。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
    301 | Moved Permanently | **永久移动**。请求的资源已被永久的移动到新URL，返回信息会包括新的URL，浏览器会自动定向到新URL。今后任何新的请求都应使用新的URL代替
    302 | Found | **临时移动**。与301类似。但资源只是临时被移动。客户端应继续使用原有URL
    303 | See Other | **查看其它地址**。与301类似。使用GET和POST请求查看
    304 | Not Modified | **未修改**。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
    305 | Use Proxy | **使用代理**。所请求的资源必须通过代理访问
    306 | Unused | 已经被废弃的HTTP状态码
    307 | Temporary Redirect | **临时重定向**。与302类似。使用GET请求重定向
    400 | Bad Request | 客户端请求的**语法错误**，服务器无法理解
    401 | Unauthorized | 请求要求用户的**身份认证**
    402 | Payment Required | 保留，将来使用
    403 | Forbidden | 服务器理解请求客户端的请求，但是**拒绝执行**此请求
    404 | Not Found | 服务器**无法根据客户端的请求找到资源**（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
    405 | Method Not Allowed | 客户端请求中的方法**被禁止**
    406 | Not Acceptable | 服务器**无法根据客户端请求的内容特性完成请求**
    407 | Proxy Authentication Required | **请求要求代理的身份认证**，与401类似，但请求者应当使用代理进行授权
    408 | Request Time-out | 服务器等待客户端发送的请求时间过长，**超时**
    409 | Conflict | 服务器完成客户端的`PUT`请求时可能返回此代码，服务器处理请求时发生了**冲突**
    410 | Gone | 客户端请求的**资源已经不存在**。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置
    411 | Length Required | 服务器**无法处理**客户端发送的不带`Content-Length`的请求信息
    412 | Precondition Failed | 客户端请求信息的**先决条件错误**
    413 | Request Entity Too Large | 由于请求的实体过大，服务器无法处理，因此**拒绝请求**。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个`Retry-After`的响应信息
    414 | Request-URL Too Large | 请求的**URL过长**（URL通常为网址），服务器无法处理
    415 | Unsupported Media Type | 服务器无法处理请求附带的**媒体格式**
    416 | Requested range not satisfiable | 客户端**请求的范围无效**
    417 | Expectation Failed | 服务器**无法满足Expect的请求头信息**
    500 | Internal Server Error | 服务器**内部错误**，无法完成请求
    501 | Not Implemented | 服务器**不支持请求的功能**，无法完成请求
    502 | Bad Gateway | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个**无效的响应**
    503 | Service Unavailable | 由于超载或系统维护，服务器暂时的**无法处理客户端的请求**。延时的长度可包含在服务器的Retry-After头信息中
    504 | Gateway Time-out | 充当网关或代理的服务器，**未及时从远端服务器获取请求**
    505 | HTTP Version not supported | 服务器**不支持请求的HTTP协议的版本**，无法完成处理

## Nginx
- **特点**：
  - `Nginx` (engine x) 是一个高性能的`HTTP`和反向代理`web`服务器，同时也提供了`IMAP`/`POP3`/`SMTP`服务，内存占用少，启动极快，高并发能力强
  ![架构图](https://pic1.zhimg.com/80/v2-e1826bab1d07df8e97d61aa809b94a10_1440w.jpg)
  - `nginx`的`master`进程需要`root`权限来启动，而`worker`进程不需要`root`权限来启动
  - 图片等静态资源目录不能给脚本执行权限
  - 禁止访问`.git`、.`svn`和`.sql`目录，可以防止因运维操作不当造成的代码或数据泄漏
- **正向代理与反向代理**
  - 被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程
  - **正向代理**“代理”的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。
![正向代理](https://pic4.zhimg.com/80/v2-c8ac111c267ae0745f984e326ef0c47f_1440w.jpg)
  - **反向代理**“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。
![反向代理](https://pic2.zhimg.com/80/v2-4787a512240b238ebf928cd0651e1d99_1440w.jpg)

## 域名
- :rocket: 通常 Internet 主机域名的一般**结构**为：主机名=>三级域名=>二级域名=>顶级域名
- :rocket: 在应用通信之前首先需要请求DNS应用，将域名映射为IP地址
### 原理
- :rocket: **层次化域名结构**：为了实现域名解析，需要建立分布式数据库，存储网络中域名与IP地址的映射关系数据,这些数据库存储在域名服务器上，域名服务器根据用户的请求提供域名解析服务
- :rocket: 域名解析对于网络用户来说是**透明**的，并将该请求发送给本地域名服务器，若本地域名服务器上没有对应的记录，则由本地域名服务器负责向上一级域名服务器申请资源，此时该 `DNS` 服务器对上层来讲也相当于一台 `DNS` 客户机。每一个域名服务器不仅能够进行一些域名地址到IP地址的解析，还应该具有连接其他域名服务器的能力。
### 过程
- 客户机（主机）**提出域名解析请求**，并将该请求发送给本地域名服务器。客户机向本地域名服务器的查询一般采用**递归查询**；
- 当本地的域名服务器收到请求之后，就先**查询本地的域名缓存**，如果有该记录项，则本地的域名服务器就直接把查询的结果**返回**；
- 如果本地的缓存中没有该及录项，则本地域名服务器就直接**把请求发给根域名服务器**，然后根域名服务器再返回给本地域名服务器一个所查询域的主域名服务器的IP；
- 本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自己的域名缓存，如果没有该记录项，则返回相关的下一级域名服务器的地址；
- 重复步骤四，直到找到正确的记录；
- 本地域名服务器把返回的结果保存到域名缓存，以备下一次使用，同时将结果返回给客户机。
![域名解析举例](https://img-blog.csdnimg.cn/20190218165332261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaWVfNTcw,size_16,color_FFFFFF,t_70)
### DNS迭代和递归的区别
- **递归查询**
  递归查询是一种DNS 服务器的查询模式，在该模式下DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。
- **迭代查询**
  DNS 服务器另外一种查询方式为迭代查询，DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果


## HTTPS
### 基本概念
- **超文本传输安全协议**(英语：Hypertext Transfer Protocol Secure，缩写：HTTPS)
- `https` 是在 `http` 基础之上，采用传输层安全层 `TLS` 或安全套接字层 `SSL` 对通信数据进行加密，从而保证数据传输的安全。
- `http`存在的**问题**
  - 数据**明文传输**
  - 无法**验证**通信双方身份
  - 无法判断数据是否**篡改**
- `https` **优化**
  - **数据传输加密**：数据传输过程不采用明文，而是加密之后再传输。
  - **信息完整性检验**：通过数字签名解密后的信息摘要验证数据的完整性。
  - **身份认证**：利用数字证书鉴别通信方身份的合法性。
### 基本要素
- `SSL`(*网景*)/`TLS`(*微软*):
  - `https` 并不是一种新的协议，而是 `http` + `SSL`/`TLS` 组合而来的（如图所示），在 `http` 和 `tcp` 之间加入`SSL`/`TLS` 协议，通过 `SSL`/`TLS` 对数据进行加密和解密，从而保证数据的安全性。
  - `https` 协议安全的核心在于 `SSL`/`TLS`，`TLS` / `SSI` 协议核心就三大步骤 ：**身份认证**、**密钥协商**、**数据加密** 。
  - `TLS`/`SSL` 的功能实现主要依赖于三类基本算法：**摘要算法** 、**对称加密**和**非对称加密**，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于摘要算法验证信息的完整性。`TLS`/`SSL` 本身不能校验通信方的合法性，引入数字证书后才能验证通信方的真实性。
  ![https](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c854454c95c40bc820a00cab3393b03~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)
- **加密**
  - `https`在传输数据过程中采用**对称加密**和**非对称加密**两种形式。在**密钥协商阶段**采用的是非对称加密，**数据传输过程**则采用对称加密。
  - **对称加密**
    - 加密和解密使用同一个密钥。常见的算法： `DES`，`3DES`，`AES` (128bits, 192bits, 256bits, 384bits) 。
    - 对称加密的优点是**加密和解密速度快**，但加密和解密采用**相同的密钥**，如果密钥泄漏，即使数据加密，也能够被解密出来。
  - **非对称加密**
    - 非对称性加密，加密解密的过程使用**不同**的密钥。常见的非对称加密算法有，`RSA`，`DH`，`ECC`，`DSA`。密钥分为公钥与私钥：
    - **公钥**：从私钥中提取产生；可公开给所有人；`pubkey`
    - **私钥**：通过工具创建，使用者自己留存，必须保证其私密性；`secret key`
    - **特点**：公钥加密，私钥解密，私钥加密，公钥解密。
    - 非对称加密的优点是**加解密采用不同的密钥**，**私钥保存在服务端**，不容易泄漏，数据加密之后不容易被破解，但加密数据时间较长。
  - 如果浏览器和服务器通信仅采用非对称加密，一旦页面数据量大，**加解密时间过长**，会导致页面加载速度较慢。而如果仅采用对称加密，在首次进行数据传输时，需要服务端和客户端保存相同的密钥，对称密钥在传输过程中依旧存在中间人攻击，对称密钥容易被截取。
  - 于是，基于对称加密和非对称加密的特点，`https`采用了两种方式共同对数据进行加密。
- **数字证书**
  - 数字证书由第三方权威机构颁发，作用是**验证服务端身份合法性**，类似于我们的身份证。颁发数字证书的机构为`Certificate Authority`，简称 `CA` 机构。
  - **证书类型**
    - `DV` 证书
    - `OV` 证书
    - `EV` 证书
- **数字签名**
  - 数字签名由颁发数字证书的 `CA` 机构生成，通过数字签名可以检验信息的完整性，确认签名者的身份。
  - 要生成数字签名，首先需要采用摘要算法对证书信息进行**单向计算**，生成一个特定长度的字符串，又称信息摘要，然后采用 `CA` 机构的私钥加密生成数字签名。
  - **摘要算法**是将任意长度的输入转化为定长输出的算法。摘要算法的结果经常被简称为散列（ hash）。摘要算法具有以下**特性**：
    - **抗原像性**（单向性） 给定一个散列，计算上无法找到或者构造出生成它的消息。
    - **抗第二原像性**（弱抗碰撞性） 给定一条消息和它的散列，计算上无法找到一条不同的消息具有相同的散列。
    - **强抗碰撞性** 计算上无法找到两条散列相同的消息
    - 常见的摘要算法有`MD5`，`SHA-1`，`SHA-2`, 目前 `SHA-1`被证明不够安全，推荐使用 `SHA-2`。
  - 浏览器**验证签名**的过程是沿着证书链向上验证，检验每一层级证书的真实性。
    - 首先，`CA` 机构利用自己的私钥对证书信息摘要进行加密得到数字签名。私钥是唯一的，只有颁发证书的机构拥有，而公钥是公开的，在 `CA` 机构的证书中，浏览器通过证书链拿到。
    - 然后，浏览器在拿到服务器证书中的数字签名时，从上一级的 `CA` 机构的数字证书中拿到公钥进行解密，会得到一个信息摘要，同时采用摘要算法将服务器证书的信息生成一个信息摘要，然后对比两个信息摘要，如果一致，则表明没有被修改，身份认证成功，不一致，则认证失败。
    ![签名验证](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbabdd8d52e14bddaca9d6208ce27219~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)
### 通信过程
![通信过程](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8b32d2266624d34bfca6651a7685a15~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)
- **握手阶段**
  1. 浏览器生成一个随机数 `client_random`，同时发送密码套件。密码套件是密码学算法组合 ，简单的讲就是浏览器支持哪些加密算法。
  2. 服务器接受浏览器发送的随机数、密码套件，然后从密码套件中选择后续加密要使用的算法，同时再生成一个随机数 `server_random`，然后将选择的密码套件、随机数和服务器的数字证书一同发送给浏览器。此时服务器和浏览器便各自拥有两个随机数。
  3. 拿到数字证书后，就可以对服务端的身份进行**验证**。验证数字证书有两个步骤，验证数字证书链和服务端数字证书。证书链一般通过服务器发送，通过证书链获取到各级CA机构的数字证书，最顶级的CA机构证书内置于浏览器或操作系统中。证书链的验证过程是利用数字签名去迭代检验，根证书的公钥和私钥都在证书中，属于自签名证书，自己验证自己。证书链的验证完成就是验证服务器的证书是否合法，包括有效期，是否吊销等等。
  4. 数字证书验证通过后，浏览器生成一个随机数 `pre_master`，又称预主密钥。然后利用服务器证书中的公钥加密预主密钥，传给服务端。服务端拿到数据之后用自己的私钥解密，获取 `pre_master`。此时服务器和浏览器各自拥有三个随机数，`client_random`，`server_random`，`pre_master`，然后将三者结合起来采用协商好的算法生成主密钥 `master_key`。这个主密钥就是后续数据传输过程对称加密的密钥，至此握手阶段结束。
- **传输阶段**
  1. 浏览器采用 master_key 和对称加密算法加密要传输的数据，传送给服务端。
  2. 服务端利用 master_key 解密数据，然后将响应数据加密，发送给浏览器。
  3. 浏览器采用 master_key 解密数据。
  4. 后续传输过程重复上述步骤。


# 音视频
## RTSP协议 **实时流协议**
- `RTSP`用于在希望通讯的两端建立并控制媒体会话`session`，客户端通过发出`VCR-style`命令如`play`、`record`和`pause`等来实时控制媒体流。
- `RTSP`处理流时会根据端点间可用带宽大小，将音视频等数据切割成小分组`packet`进行传输，使得客户端在播放一个分组的同时，可以解压缓存中第二个甚至下载第三个分组。通过缓存和多码率流技术，用户将不会感觉到数据间存在停顿。
- **特点**：
  - 多服务器兼容：媒体流可来自不同服务器
  - 可协商：客户端和服务器可协商`feature`支持程度
  - `HTTP`亲和性：尽可能重用`HTTP`概念，包括认证、状态码、解析等
  - 易解析：`HTML`或`MIME`解析器均可在`RTSP`中适用
  - 易扩展：新的方法或参数甚至协议本身均可添加或定制
  - 防火墙亲和性：传输层或应用层防火墙均可被协议较好处理
  - 服务器控制：控制概念易于理解，服务器不允许向客户端传输不能被客户端关闭的流
  - 多场景适用：`RTSP`提供帧级别精度，适用于更多媒体应用场景
- **相关协议介绍**
  - `RTSP`组合使用了可靠传输协议`TCP`（控制）和高效传输协议`UDP`（内容）来串流`streaming`内容给用户。它支持点播`Video-On-Demand`以及直播`Live Streaming`服务。
  - `RTSP`协议本身并不负责数据传输，通常（非必须）是通过`RTP`（Real-time Transport Protocol）配合`RTCP`（Real-time Control Protocol）完成数据流和控制命令（同步、`QOS`管理等）的传输。具体应用中，三者的关系如下图所示：
![示意图](https://upload-images.jianshu.io/upload_images/2686562-c403ed80d325caf5.png?imageMogr2/auto-orient/strip|imageView2/2/w/538/format/webp)
- RTSP方法
  - `RTSP`中并没有连接的概念，而是通过会话`Session`进行管理。每个会话有对应的会话`ID`，会话中可能可能涉及一至多个流，会话生命周期中，客户端也可能切换连接（如`TCP`）来传递`RTSP`请求。

    method | direction | object | requirement
    | :---: | :---: | :---: | :---: |
    DESCRIBE | C->S | P,S | recommended
    ANNOUNCE | C->S, S->C | P,S | optional
    GET_PARAMETER | C->S, S->C | P,S | optional
    OPTIONS | C->S, S->C | P,S | required(S->C:optional)
    PAUSE | C->S | P,S | recommended
    PLAY | C->S | P,S | required
    RECORD | C->S | P,S | optional
    REDIRECT | S->C | P,S | optional
    SETUP | C->S | S | required
    SET_PARAMETER | C->S,S->C | P,S | optional
    TEARDOWN | C->S | P,S | required
    - P: 呈现（Presentation），S:流（Stream）
  - 一个RTSP应用（如点播）生命周期内，通常会话（所有交互）过程如下图所示：
    ![交互](https://upload-images.jianshu.io/upload_images/2686562-887491450f364b39.gif?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)

## RTMP协议
- RTMP（Real Time Messaging Protocol） 是由Adobe公司基于Flash Player播放器对应的音视频flv封装格式提出的一种，基于TCP的数据传输协议。本身具有稳定、兼容性强、高穿透的特点。常被应用于流媒体直播、点播等场景。常用于推流方（主播）的稳定传输需求。
- 传输：
  - RTMP协议为了维持稳定连续传递，避免单次传输数据量问题，采用了传输层封包，数据流切片的实现形式。被用来对当前带宽进行划分和复用的最小传输单位，被称为`Chunk`即消息块。
  - 通常情况下，一个有效的消息，如果数据量超出当前`Chunk Size`的话，则会被拆分成多个分块来分批传输。通过指定首个`Chunk`和后续`Chunk`类型，以及`Chunk Header`其他标志性数据，来使当前被切割的消息，能够在对端得到有效的还原和执行。
- 消息块
  - RTMP 协议是以分组形式传送数据包。一个完整的数据块包含两个部分：`Chunk Header` 和 `Chunk Data`，这两者组合在一起，构成了一个有效的消息类型，结构如下：
  ![消息块组成](https://pic4.zhimg.com/80/v2-69e1874e73bd8ca5a0391650975d64a7_1440w.png)
  - 基础数据头（Basic Header）：保存 `CS ID`、`Chunk Type`（决定 `Msg Header` 类型）
  - 消息数据头（Message Header）：包含被发送消息的相关信息，类型`Chunk Type`决定
  - 扩展时间戳（Extended Timestamp）（`32-bits`）：消息头携带的时间戳扩展位


# 安全


# 浏览器