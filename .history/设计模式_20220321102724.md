# 概述
- :rocket: 设计模式就是对大家经常碰到的问题进行了最佳实践的总结，并给它起了一个方便记忆的名字。
- 类型
  - **结构型模式**（Structural Patterns）： 通过识别系统中组件间的简单关系来简化系统的设计。
  - **创建型模式**（Creational Patterns）： 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。
  - **行为型模式**（Behavioral Patterns）： 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。
![设计模式类型](https://pic1.zhimg.com/80/v2-df2db167360afb5825cf1e693b015ca8_1440w.jpg)

# 结构性模式
## 外观模式
![外观模式](https://pic3.zhimg.com/80/v2-7ca3af3e038c928ada59d6caad33836a_1440w.jpg)
- **外观模式**是最常见的设计模式之一，它为子系统中的一组接口提供一个统一的高层接口，使子系统更容易使用。
- 简而言之外观设计模式就是把多个子系统中复杂逻辑进行**抽象**，从而提供一个更统一、更简洁、更易用的API。很多我们常用的框架和库基本都遵循了外观设计模式，比如`JQuery`就把复杂的原生`DOM`操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。

## 代理模式
![代理模式](https://pic4.zhimg.com/80/v2-05375788fe022386dc968c8d4bdf270f_1440w.jpg)
- :house: 首先，**一切皆可代理**，不管是在实现世界还是计算机世界。
- ::当访问一个对象本身的**代价太高**（比如太占内存、初始化时间太长等）或者需要**增加额外的逻辑**又不修改对象本身时便可以使用代理。`ES6`中也增加了`Proxy`的功能。
- 解决的**问题**
  - 增加对一个对象的访问控制
  - 当访问一个对象的过程中需要增加额外的逻辑
- 要实现代理模式需要**三部分**：
  - `Real Subject`：真实对象
  - `Proxy`：代理对象
  - `Subject`接口：`Real Subject` 和 `Proxy`都需要实现的接口，这样`Proxy`才能被当成`Real Subject`的“替身”使用