# 概述
- :rocket: 设计模式就是对大家经常碰到的问题进行了最佳实践的总结，并给它起了一个方便记忆的名字。
- :house: **类型**
  - **结构型模式**（Structural Patterns）： 通过识别系统中组件间的简单关系来简化系统的设计。
  - **创建型模式**（Creational Patterns）： 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。
  - **行为型模式**（Behavioral Patterns）： 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。
![设计模式类型](https://pic1.zhimg.com/80/v2-df2db167360afb5825cf1e693b015ca8_1440w.jpg)
  - **架构型设计模式**: 为了将业务和视图的实现代码分离，从而使同一个程序可以使用不同的表现形式。
# 结构性模式
## 外观模式
![外观模式](https://pic3.zhimg.com/80/v2-7ca3af3e038c928ada59d6caad33836a_1440w.jpg)
- **外观模式**是最常见的设计模式之一，它为子系统中的一组接口提供一个统一的高层接口，使子系统更容易使用。
- 简而言之外观设计模式就是把多个子系统中复杂逻辑进行**抽象**，从而提供一个更统一、更简洁、更易用的API。很多我们常用的框架和库基本都遵循了外观设计模式，比如`JQuery`就把复杂的原生`DOM`操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。

## 代理模式
![代理模式](https://pic4.zhimg.com/80/v2-05375788fe022386dc968c8d4bdf270f_1440w.jpg)
- :house: 首先，**一切皆可代理**，不管是在实现世界还是计算机世界。
- :white_check_mark: 当访问一个对象本身的**代价太高**（比如太占内存、初始化时间太长等）或者需要**增加额外的逻辑**又不修改对象本身时便可以使用代理。`ES6`中也增加了`Proxy`的功能。
- :white_check_mark: 解决的**问题**
  - 增加对一个对象的访问控制
  - 当访问一个对象的过程中需要增加额外的逻辑
- :white_check_mark: 要实现代理模式需要**三部分**：
  - :rocket: `Real Subject`：真实对象
  - :rocket: `Proxy`：代理对象
  - :rocket: `Subject`接口：`Real Subject` 和 `Proxy`都需要实现的接口，这样`Proxy`才能被当成`Real Subject`的“替身”使用

# 创建型模式
## 工厂模式
![工厂模式](https://pic4.zhimg.com/80/v2-94d59dbbc541849d398ffe4532f3e0a3_1440w.jpg)
- :house: 工厂可以看成是一个制造其他对象的对象，制造出的对象也会随着传入工厂对象参数的不同而有所区别。
- :white_check_mark: 当**构造函数过多**不方便管理，且需要创建的对象之间存在**某些关联**（有同一个父类、实现同一个接口等）时，不妨使用工厂模式。
- :white_check_mark: 工厂模式提供一种**集中化**、**统一化**的方式，避免了**分散创建对象**导致的**代码重复**、**灵活性差**的问题。
- :white_check_mark: 使用工厂模式之后，不再需要重复引入一个个构造函数，只需要引入工厂对象就可以方便的创建各类对象。

## 单例模式
![单例模式](https://pic4.zhimg.com/80/v2-50bef18b2e069fa5611a680efd396a4b_1440w.jpg)
- :house: 顾名思义，单例模式中`Class`的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。
- :white_check_mark: 而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。
- :o2: 实现单例模式需要解决以下几个**问题**：
  - :rocket: 如何确定`Class`只有一个实例？
  - :rocket: 如何简便的访问`Class`的唯一实例？
  - :rocket: `Class`如何控制实例化的过程？
  - :rocket: 如何将`Class`的实例个数限制为1？
- :white_check_mark: 一般通过实现以下两点来解决上述问题：
  - :rocket: 隐藏`Class`的构造函数，避免**多次**实例化
  - :rocket: 通过暴露一个 `getInstance()` 方法来创建/获取**唯一**实例

# 行为型模式
## 策略模式
![策略模式](https://pic1.zhimg.com/80/v2-7c20e73fdade6615874821f7e06f8ab4_1440w.jpg)
- :house: 策略模式简单**描述**就是：对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。
  - :rocket: 最常见的使用策略模式的场景如登录鉴权，鉴权算法取决于用户的登录方式是手机、邮箱或者第三方的微信登录等等，而且登录方式也只有在运行时才能获取，获取到登录方式后再动态的配置鉴权策略。
- :white_check_mark: 所有这些策略应该实现统一的接口，或者说有统一的行为模式。`Node` 生态里著名的鉴权库 `Passport.js` API的设计就应用了策略模式。
- :white_check_mark: **优势**
  - :rocket: 方便在运行时切换算法和策略
  - :rocket: 代码更简洁，避免使用大量的条件判断
  - :rocket: 关注分离，每个`strategy`类控制自己的算法逻辑，`strategy`和其使用者之间也相互独立

## 迭代器模式
![迭代器模式](https://pic2.zhimg.com/80/v2-83b7c4f76fa28844546dfb760f00be19_1440w.jpg)
- :house: 迭代器用于遍历容器（集合）并访问容器中的元素，而且无论容器的数据结构是什么（`Array`、`Set`、`Map`等），迭代器的接口都应该是一样的，都需要遵循**迭代器协议**。
- :white_check_mark: 迭代器模式解决了以下**问题**：
  - :rocket: 提供**一致的**遍历各种数据结构的方式，而不用了解数据的内部结构
  - :rocket: 提供**遍历容器**（集合）的能力而无需改变容器的接口
- :white_check_mark: 一个迭代器通常需要实现以下**接口**：
  - :rocket: hasNext()：判断迭代**是否结束**，返回`Boolean`
  - :rocket: next()：查找并返回**下一个元素**

## 观察者模式
![观察者模式](https://pic2.zhimg.com/80/v2-b30b0a7a7fb8560f151b246002154f9d_1440w.jpg)
- :house: 观察者模式又称发布订阅模式`Publish/Subscribe Pattern`，是我们经常接触到的设计模式
  - 比如你订阅了某个博主的频道，当有内容更新时会收到推送
  - 又比如JavaScript中的**事件订阅响应机制**
- :white_check_mark: 观察者模式的思想用一句话描述就是：被观察对象`subject`维护一组观察者`observer`，当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者。
- :white_check_mark: 观察者模式中`Subject`对象一般需要实现以下API：
  - `subscribe()`: 接收一个观察者`observer`对象，使其订阅自己
  - `unsubscribe()`: 接收一个观察者`observer`对象，使其取消订阅自己
  - `fire()`: 触发事件，通知到所有观察者

## 中介者模式
![中介者模式](https://pic3.zhimg.com/80/v2-a4ec4deb78373a1c936a64e65ec77052_1440w.jpg)
- :house: 在中介者模式中，中介者`Mediator`包装了一系列**对象相互作用**的方式，使得这些对象不必直接相互作用，而是由中介者协调它们之间的交互，从而使它们可以松散偶合。
- :white_check_mark: 当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。
- :white_check_mark: 中介者模式和观察者模式有一定的相似性，都是**一对多**的关系，也都是**集中式通信**，不同的是中介者模式是处理**同级对象**之间的交互，而观察者模式是处理`Observer`和`Subject`之间的交互。
  - :rocket: 中介者模式有些像婚恋中介，相亲对象刚开始并不能直接交流，而是要通过中介去筛选匹配再决定谁和谁见面。
  - :rocket: 中介者模式比较常见的应用比如聊天室，聊天室里面的人之间并不能直接对话，而是通过聊天室这一媒介进行转发。

## 访问者模式
![访问者模式](https://pic2.zhimg.com/80/v2-2656b6d0e848450ce4d9e216715f1fed_1440w.jpg)
- :house: 访问者模式是一种**将算法与对象结构分离的设计模式**
- :white_check_mark: 通俗点讲就是：访问者模式让我们能够在不改变一个对象结构的前提下能够给该对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中。访问者模式常用于拓展一些第三方的库和工具。
- :white_check_mark: 访问者模式的实现有以下几个要素：
  - `Visitor Object`：访问者对象，拥有一个 `visit()` 方法
  - `Receiving Object`：接收对象，拥有一个 `accept()` 方法
  - `visit(receivingObj)`：用于`Visitor`接收一个`Receiving Object`
  - `accept(visitor)`：用于`Receving Object`接收一个`Visitor`，并通过调用`Visitor`的 `visit()` 为其提供获取`Receiving Object`数据的能力

# 架构型模式
## MVC模式
