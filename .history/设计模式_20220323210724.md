# 概述
- :rocket: 设计模式就是对大家经常碰到的问题进行了最佳实践的总结，并给它起了一个方便记忆的名字。
- :house: **类型**
  - **结构型模式**（Structural Patterns）： 通过识别系统中组件间的简单关系来简化系统的设计。
  - **创建型模式**（Creational Patterns）： 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。
  - **行为型模式**（Behavioral Patterns）： 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。
![设计模式类型](https://pic1.zhimg.com/80/v2-df2db167360afb5825cf1e693b015ca8_1440w.jpg)
  - **架构型设计模式**: 为了将业务和视图的实现代码分离，从而使同一个程序可以使用不同的表现形式。
# 结构性模式
## 外观模式
![外观模式](https://pic3.zhimg.com/80/v2-7ca3af3e038c928ada59d6caad33836a_1440w.jpg)
- **外观模式**是最常见的设计模式之一，它为子系统中的一组接口提供一个统一的高层接口，使子系统更容易使用。
- 简而言之外观设计模式就是把多个子系统中复杂逻辑进行**抽象**，从而提供一个更统一、更简洁、更易用的API。很多我们常用的框架和库基本都遵循了外观设计模式，比如`JQuery`就把复杂的原生`DOM`操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。

## 代理模式
![代理模式](https://pic4.zhimg.com/80/v2-05375788fe022386dc968c8d4bdf270f_1440w.jpg)
- :house: 首先，**一切皆可代理**，不管是在实现世界还是计算机世界。
- :white_check_mark: 当访问一个对象本身的**代价太高**（比如太占内存、初始化时间太长等）或者需要**增加额外的逻辑**又不修改对象本身时便可以使用代理。`ES6`中也增加了`Proxy`的功能。
- :white_check_mark: 解决的**问题**
  - 增加对一个对象的访问控制
  - 当访问一个对象的过程中需要增加额外的逻辑
- :white_check_mark: 要实现代理模式需要**三部分**：
  - :rocket: `Real Subject`：真实对象
  - :rocket: `Proxy`：代理对象
  - :rocket: `Subject`接口：`Real Subject` 和 `Proxy`都需要实现的接口，这样`Proxy`才能被当成`Real Subject`的“替身”使用

# 创建型模式
## 工厂模式
![工厂模式](https://pic4.zhimg.com/80/v2-94d59dbbc541849d398ffe4532f3e0a3_1440w.jpg)
- :house: 工厂可以看成是一个制造其他对象的对象，制造出的对象也会随着传入工厂对象参数的不同而有所区别。
- :white_check_mark: 当**构造函数过多**不方便管理，且需要创建的对象之间存在**某些关联**（有同一个父类、实现同一个接口等）时，不妨使用工厂模式。
- :white_check_mark: 工厂模式提供一种**集中化**、**统一化**的方式，避免了**分散创建对象**导致的**代码重复**、**灵活性差**的问题。
- :white_check_mark: 使用工厂模式之后，不再需要重复引入一个个构造函数，只需要引入工厂对象就可以方便的创建各类对象。

## 单例模式
![单例模式](https://pic4.zhimg.com/80/v2-50bef18b2e069fa5611a680efd396a4b_1440w.jpg)
- :house: 顾名思义，单例模式中`Class`的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。
- :white_check_mark: 而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。
- :o2: 实现单例模式需要解决以下几个**问题**：
  - :rocket: 如何确定`Class`只有一个实例？
  - :rocket: 如何简便的访问`Class`的唯一实例？
  - :rocket: `Class`如何控制实例化的过程？
  - :rocket: 如何将`Class`的实例个数限制为1？
- :white_check_mark: 一般通过实现以下两点来解决上述问题：
  - :rocket: 隐藏`Class`的构造函数，避免**多次**实例化
  - :rocket: 通过暴露一个 `getInstance()` 方法来创建/获取**唯一**实例

# 行为型模式
## 策略模式
![策略模式](https://pic1.zhimg.com/80/v2-7c20e73fdade6615874821f7e06f8ab4_1440w.jpg)
- :house: 策略模式简单**描述**就是：对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。
  - :rocket: 最常见的使用策略模式的场景如登录鉴权，鉴权算法取决于用户的登录方式是手机、邮箱或者第三方的微信登录等等，而且登录方式也只有在运行时才能获取，获取到登录方式后再动态的配置鉴权策略。
- :white_check_mark: 所有这些策略应该实现统一的接口，或者说有统一的行为模式。`Node` 生态里著名的鉴权库 `Passport.js` API的设计就应用了策略模式。
- :white_check_mark: **优势**
  - :rocket: 方便在运行时切换算法和策略
  - :rocket: 代码更简洁，避免使用大量的条件判断
  - :rocket: 关注分离，每个`strategy`类控制自己的算法逻辑，`strategy`和其使用者之间也相互独立

## 迭代器模式
![迭代器模式](https://pic2.zhimg.com/80/v2-83b7c4f76fa28844546dfb760f00be19_1440w.jpg)
- :house: 迭代器用于遍历容器（集合）并访问容器中的元素，而且无论容器的数据结构是什么（`Array`、`Set`、`Map`等），迭代器的接口都应该是一样的，都需要遵循**迭代器协议**。
- :white_check_mark: 迭代器模式解决了以下**问题**：
  - :rocket: 提供**一致的**遍历各种数据结构的方式，而不用了解数据的内部结构
  - :rocket: 提供**遍历容器**（集合）的能力而无需改变容器的接口
- :white_check_mark: 一个迭代器通常需要实现以下**接口**：
  - :rocket: hasNext()：判断迭代**是否结束**，返回`Boolean`
  - :rocket: next()：查找并返回**下一个元素**

## 观察者模式
![观察者模式](https://pic2.zhimg.com/80/v2-b30b0a7a7fb8560f151b246002154f9d_1440w.jpg)
- :house: 观察者模式又称发布订阅模式`Publish/Subscribe Pattern`，是我们经常接触到的设计模式
  - 比如你订阅了某个博主的频道，当有内容更新时会收到推送
  - 又比如JavaScript中的**事件订阅响应机制**
- :white_check_mark: 观察者模式的思想用一句话描述就是：被观察对象`subject`维护一组观察者`observer`，当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者。
- :white_check_mark: 观察者模式中`Subject`对象一般需要实现以下API：
  - `subscribe()`: 接收一个观察者`observer`对象，使其订阅自己
  - `unsubscribe()`: 接收一个观察者`observer`对象，使其取消订阅自己
  - `fire()`: 触发事件，通知到所有观察者

## 中介者模式
![中介者模式](https://pic3.zhimg.com/80/v2-a4ec4deb78373a1c936a64e65ec77052_1440w.jpg)
- :house: 在中介者模式中，中介者`Mediator`包装了一系列**对象相互作用**的方式，使得这些对象不必直接相互作用，而是由中介者协调它们之间的交互，从而使它们可以松散偶合。
- :white_check_mark: 当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。
- :white_check_mark: 中介者模式和观察者模式有一定的相似性，都是**一对多**的关系，也都是**集中式通信**，不同的是中介者模式是处理**同级对象**之间的交互，而观察者模式是处理`Observer`和`Subject`之间的交互。
  - :rocket: 中介者模式有些像婚恋中介，相亲对象刚开始并不能直接交流，而是要通过中介去筛选匹配再决定谁和谁见面。
  - :rocket: 中介者模式比较常见的应用比如聊天室，聊天室里面的人之间并不能直接对话，而是通过聊天室这一媒介进行转发。

## 访问者模式
![访问者模式](https://pic2.zhimg.com/80/v2-2656b6d0e848450ce4d9e216715f1fed_1440w.jpg)
- :house: 访问者模式是一种**将算法与对象结构分离的设计模式**
- :white_check_mark: 通俗点讲就是：访问者模式让我们能够在不改变一个对象结构的前提下能够给该对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中。访问者模式常用于拓展一些第三方的库和工具。
- :white_check_mark: 访问者模式的实现有以下几个要素：
  - `Visitor Object`：访问者对象，拥有一个 `visit()` 方法
  - `Receiving Object`：接收对象，拥有一个 `accept()` 方法
  - `visit(receivingObj)`：用于`Visitor`接收一个`Receiving Object`
  - `accept(visitor)`：用于`Receving Object`接收一个`Visitor`，并通过调用`Visitor`的 `visit()` 为其提供获取`Receiving Object`数据的能力

# 架构型模式
## MVC模式
- :house: 在 MVC 中，对应用程序划分出了三种角色：`Model`、`View`、`Controller`。三者有各自的具体用途和职责，并通过彼此的相互通信实现程序功能。
### 概述
- **Model**
  - `Model` 层主要管理业务模型的**数据**和**行为**，它既保存程序的数据，也定义了处理该数据的逻辑，所以 **`Model` = 数据 + 业务逻辑**。因此，处理业务逻辑属于 `Model` 的职责，而非 `Controller`。
  - 从数据的**维度**来说，可以细分为数据的**定义**、数据的**存储**、数据的**获取**。数据的定义其实就是定义数据结构，一般用实体类来定义，以方便在不同角色间传递数据。数据的存储和获取则可能有几种途径：数据库、网络或缓存等。
  - 在实际应用中，一个 `Model` 并不只是简单的一个对象，而是一个更广泛的层级。很多时候，会将 `Model` 层再进行**分解**，比如应用于客户端程序时，可以将 `Model` 层再细分为业务逻辑层、网络层、存储层等，而实体类其实只是贯穿其中的一种数据结构而已。
  - 狭义上，当我们说一个 `Model` 对象的时候，主要是对外部组件而言的，更多是指这个 `Model` 对外所提供的数据，并不关心数据从何而来。这可能就是让很多人将 `Model` 误认为就是实体类的原因。
- **View**
  - `View` 会接收用户的交互请求并展示数据信息给用户。
  - 一个 `View` 展示的数据可能只是一个 `Model` 对象的部分数据，也可能是一个 `Model` 对象的全部数据，甚至可能是多个 `Model` 对象数据的组合。
  - 在 `MVC` 里，`View` 被设计为可嵌套的，使用了`Composite`组合模式来实现。
- **Controller**
  - `Controller` 层主要担任 `Model` 与 `View` 之间的桥梁，用于**控制程序的流程**。`Controller` 负责确保 `View` 可以访问到需要显示的 `Model` 对象数据，并充当 `View` 了解 `Model` 更改的渠道。`View` 接收到用户的交互请求之后，会将请求转发给 `Controller`，`Controller` 解析用户的请求之后，就会交给对应的 `Model` 去处理。因此，理论上，`Controller` 应该是很轻的。

### 最初的版本通信机制
  ![MVC](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e498763c1af4882952a82b5b0bc6ca1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)
- 该版本的 `MVC` 其实可以看成是由三个基本设计模式组合而成：**组合模式**、**策略模式**、**观察者模式**。
  - **组合模式**前面已经讲过，就是用在了 `View` 层。
  - `View` 与 `Controller` 之间则用了**策略模式**，`Controller` 对象为一个或多个 `View` 对象实现了策略，`View` 对象仅限于保持其视觉外观，而与程序逻辑相关的所有决策都委托给 `Controller`，即 `View` 可以使用不同的 `Controller` 实现，得到不同的行为。
  - `Model` 与 `View` 之间则使用了**观察者模式**，`View` 会注册为 `Model` 的观察者，当 `Model` 有变化的时候，就能通知到 `View`。
- **交互流程**
  1. 用户**操纵** `View`，接着**生成**一个事件。比如用户点击某个按钮，则会生成一个点击事件。
  2. `Controller` 对象**接收**事件并**解释**该事件，即，它应用了策略。该策略可以是请求 `Model` 对象以更改其状态，或请求 `View` 以更改其行为或外观。比如，一个注册按钮产生的事件被 `Controller` 接收之后，那它就会**解释**该事件，可能先校验用户的输入是否为空，如果为空则请求 `View` 提示让用户填写用户名和密码等；如果校验通过，那就请求 `UserModel` 创建新用户。
  3. 当**状态改变**时，`Model` 对象又通知所有已注册为观察者的对象。如果观察者是 `View` 对象，则可以相应地**更新**其外观或行为。还是上面的例子，`UserModel` 创建新用户成功后，就可以通知观察者们，相应的 `View` 对象接收到 `UserModel` 创建新用户成功的通知后，就可以跳转到注册成功后的页面了。
- `MVC` 最初版本的通信机制，自 1979 年提出之后就被广泛应用在 `GUI` 程序中。请注意，那时候还没有 `HTTP`。后来随着微软 `ASP.NET MVC Framework` 的出现，`MVC` 也开始被广泛应用于 `Web` 程序。
### 变种MVC通信机制
- 以上版本的 MVC，由于 View 依赖了 Model，实际上减低了 View 的可复用性。那么，如果能将 View 和 Model 彻底解耦，那就可以提高 View 的可复用性了。
![MVC](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a08c7f1a7130476180d1e0c4078fd9af~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)
- `View` 和 `Model` 不直接通信了，而统一通过 `Controller` 实现数据的传递。`Model` 将结果告知 `Controller`，`Controller` 再去更新 `View`。
- 与三层架构**差别**
  - 三层架构分别为：**表现层**、**业务逻辑层**、**数据访问层**。虽然和 `MVC` 的通信方式很相似，但划分的各层的职责是不同的
  - 最重要的是，两者的**使用范围不同**。三层架构是从整个应用程序架构的角度来划分的三层，而 MVC 只是**表现层**里再进行功能划分的设计方案
- `IOS`实际应用：
![IOS-MVC](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a48a236f865c4cff90261e0c90d69e04~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

### 总结
- `MVC` 为**业务和视图的实现分离**提供了开创性的设计思路，让负责业务逻辑的 `Model` 与负责展示的 `View` 实现了解耦，从而 `Model` 的复用性高，多个 `View` 就可以共享一个 `Model`，以及，在不修改 `Model` 的情况下就可以替换 `View` 的表现形式。
- 在交互上，早期的 `MVC`，`Vie`w 是直接**依赖**于 `Model` 的，因此，`View` 的可复用性其实是受限制的。另外，这种模式其实也不**适用于前后端分离**的 `Web` 程序。因此，发展出了变种的 `MVC`，将 `View` 和 `Model` 的直接依赖**切断**，统一通过 `Controller` 进行**调度**，从而提高了 `View` 的**可复用性**，以及也可以将 `MVC` 扩展应用到前后端分离的 `Web` 程序。
- 在交互上，早期的 `MVC`，`View` 是直接依赖于 `Model` 的，因此，`View` 的可复用性其实是受限制的。另外，这种模式其实也不适用于前后端分离的 `Web` 程序。因此，发展出了变种的 `MVC`，将 `View` 和 `Model` 的直接依赖切断，统一通过 `Controller` 进行调度，从而提高了 `View` 的可复用性，以及也可以将 `MVC` 扩展应用到前后端分离的 `Web` 程序。