# 基本问题
## 陈述
### 自我介绍
- **注意**
  - 时间控制在1-3分钟
  - 准备几个亮点，不要背简历里面有的东西
- 面试官你好！我叫许芷铭，来自东北大学信息学院。我的专业为电子信息，在2021.2至今，我主要负责工程项目中前端及客户端开发。2021.7后，我也负责统筹安排工程组工作排期与和甲方沟通汇报的工作。在此期间，我先后开发了基于Qt的Windows客户端与基于Vue的Web前端单页应用，并基于electron进行了封装。我在工作中学到了很多，先后接触了python、c++、java、JavaScript等常见编程语言，了解了算法开发、Windows客户端开发、Android开发与前端开发的相关知识，在这些技术之中，我最享受Web前端开发的工作过程，并决定在毕业后继续从事前端开发工作。在研究生期间，我的研究方向为非特定性人群异常检测与目标检测，并正在将其整合入项目中。在研究与工作的过程中，我认为我具备认真负责、热爱钻研的特点，并具备较强的时间观念、沟通能力。我的爱好也比较广泛，比如乐器、运动等。这是我的自我介绍，谢谢！
## 反问
- 前端的发展方向
- 可以问本职岗位工作要求、职责。
- 可以问公司、公司的业务、体系、行业、客户。
- 可以问什么时候面试结果通知。

## 提问
### 希望自己能从实习中有一个怎样的收获，实习的话主要想做哪方面的工作
### 学了多久，怎么学的，看过哪些书
### 你觉得在开发中，规范有什么作用，带来了哪些好处
### 有了解过哪些新技术
### 未来规划

# 理论知识
## CSS
### `rem`是什么
### `rem` 和 `em` 的区别
- em是**相对长度单位**。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。
  - em的值并不是固定的；
  - em会继承父级元素的字体大小。
  - 任意浏览器的默认字体高都是16px
- rem是CSS3新增的一个相对单位
  - 区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。
  - 通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应
- 对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 。
- 对于需要适配各种移动设备，使用rem
### 百分比布局
- 百分比布局，又称弹性布局、流式布局。
- 通过将盒子的宽度设置成百分比,从而根据屏幕的宽度来进行伸缩,不受固定像素的限制,内容向两侧填充。
- 制作过程中,需要定义页面的最大和最小支持宽度。
### 响应式布局
- 早年设计Web时，页面是以适配特定的屏幕大小为考量创建的。如果用户正在使用比设计者考虑到的更小或者更大的屏幕，那么结果从多余的滚动条，到过长的行和没有被合理利用的空间，不一而足。随着人们使用的屏幕尺寸的种类越来越多，出现了响应式网页设计的概念。RWD指的是允许Web页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践。
- 响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够，缺点就是CSS比较重。
- 实现方案：
  - 媒体查询：CSS3媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。
  - 百分比布局：通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。
  - REM是CSS3新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。 因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。

### 媒体查询 
- 通过媒体查询（Media queries），您可以根据各种设备特征和参数的值或者是否存在来调整您的网站或应用。
- 它们是响应式设计 (en-US)的关键组成部分。
- 可在HTML与js中使用
### css各种定位，每种定位相对于哪，每种定位的特点
#### static
- static是position属性的默认值
- 浏览器会按照源码的顺序，决定每个元素的位置
- static定位所导致的元素位置，是浏览器自主决定的，所以这时top、bottom、left、right这四个属性无效。
![static](https://www.wangbase.com/blogimg/asset/201911/bg2019111720.jpg)
#### relative
- relative表示，相对于默认位置（即static时的位置）进行偏移，即定位基点是元素的默认位置
- 它必须搭配top、bottom、left、right这四个属性一起使用，用来指定偏移的方向和距离。
  ![](https://www.wangbase.com/blogimg/asset/201911/bg2019111721.jpg)
#### absolute
- absolute表示，相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。
- 限制条件：定位基点（一般是父元素）不能是static定位，否则定位基点就会变成整个网页的根元素html。另外，absolute定位也必须搭配top、bottom、left、right这四个属性一起使用。
- absolute定位的元素会被"正常页面流"忽略，即在"正常页面流"中，该元素所占空间为零，周边元素不受影响。
  ![](https://www.wangbase.com/blogimg/asset/201911/bg2019111801.jpg)
#### fixed
- fixed表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。
- 它如果搭配top、bottom、left、right这四个属性一起使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。
  ![](https://www.wangbase.com/blogimg/asset/201911/bg2019111802.jpg)
#### sticky
- sticky跟前面四个属性值都不一样，它会产生动态效果，很像relative和fixed的结合：一些时候是relative定位（定位基点是自身默认位置），另一些时候自动变成fixed定位（定位基点是视口）。
- sticky生效的前提是，必须搭配top、bottom、left、right这四个属性一起使用，不能省略，否则等同于relative定位，不产生"动态固定"的效果。原因是这四个属性用来定义"偏移距离"，浏览器把它当作sticky的生效门槛。
- 当页面滚动，父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到生效门槛，relative定位自动切换为fixed定位；等到父元素完全脱离视口时（即完全不可见），fixed定位自动切换回relative定位。
### :rocket: `flex`布局的意义，再详细介绍
- 它能够扩展和收缩 flex 容器内的元素，以最大限度地填充可用空间。与以前布局方式（如 table 布局和浮动元素内嵌块元素）相比，Flexbox 是一个更强大的方式
  - 在不同方向排列元素
  - 重新排列元素的显示顺序
  - 更改元素的对齐方式
  - 动态地将元素装入容器
### css选择器权重值和优先级
### css样式隔离
1. 通过 `style` 标签的 `scoped` 指令定义作用域，通过编译为该作用域所有标签生成唯一的属性。
2. css 模块化：`CSS Modules` 指的是我们像 `import js` 一样去引入我们的 `css` 代码，代码中的每一个类名都是引入对象的一个属性, 编译时会将 `css` 类名加上唯一 `hash`。`css module` 需要 `webpack` 配置 `css-loader` 或者 `scss-loader` , `module` 为 `true`。
### `Position` 属性有哪几个值

### Flex
<a src="https://juejin.cn/post/6844904016439148551">参考</a>

#### flex-basis
- 在Flex布局中，一个Flex子项的宽度是由元素自身尺寸，flex-basis设置的基础尺寸，以及外部填充（flex-grow）或收缩（flex-shrink）规则3者共同决定的。
- 在Flex布局中，子项设置width是没有直接效果的。`flex-basis:auto` （默认）时取width值。flex-basis优先级是比width高的（可以理解为覆盖）
#### flex-grow
- 剩余空间：x
- 假设有三个flex item元素，flex-grow 的值分别为a, b, c
- 每个元素可以分配的剩余空间为： a/(a+b+c) * x，b/(a+b+c) * x，c/(a+b+c) * x
- 实际空间：basis+分配的空间
#### flex-shrink
- 三个flex item元素的width: w1, w2, w3
- 三个flex item元素的flex-shrink：a, b, c
- 计算总压缩权重：sum = a * w1 + b * w2 + c * w3
- 计算每个元素压缩率：S1 = a * w1 / sum，S2 =b * w2 / sum，S3 =c * w3 / sum
- 计算每个元素宽度：width - 压缩率 * 溢出空间


## JavaScript
### 介绍一下原型链, 从构造函数到原型，再到原型链，盗用构造函数，原型式继承，寄生式继承，寄生式继承如何弥补了普通原型链的缺点。手写了原型式继承，以及手写寄生式继承如何连接父子构造函数。
### 异步任务有哪些
### 讲讲有哪些宏任务和微任务，以及它们的循环方式，之后思考对于宏任务和微任务队列的实现方式
- 给了几个思路，1. 二维数组 2. 哈希散列 3. 数组链表
### 数据类型有哪些
### 怎么判断数据类型
### 判断数组的方式
- 五种，1. `typeof` 2. `constructor` 3. `instanceof` 4. `Object.prototype.toString.call` 5. `Array.isArray`
- 说说 3 4 5 方式的区别
### ES6相关，新增属性 :three:
- 解构赋值、扩展运算符、`Symbol`、`Map`与`Set`、`filter`、`reduce`、箭头函数、`promise`、`let`与`const`块级作用域
### `Promise`, `Generator`原理，优缺点 :three:
### `promise`有几个状态? `promise.catch`后, 后面的`.then`还会执行吗
- `catch`也会返回一个 `promise` 所以可以继续 `then`
- 从语义上也很好理解, 都被捕获处理过了就不是`error`了 所以可以继续
### 给一个 `dom` 同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获
- `addEventListener`绑定几次就执行几次   先捕获，后冒泡
### 深浅拷贝 有哪些方法实现深拷贝
1. `JSON.parse(JSON.stringify(obj))`  (弊端：正则函数、日期会有问题，变成空对象或字符串)
2. 使用递归的方式
3. 函数库`lodash`的`_.cloneDeep()`
4. 通过`$.extend()`实现深拷贝，当`extend`内的第一个参数为`true`时，实现的是深拷贝，`false`是浅拷贝。
5. `Object.assign()`，当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。
### 箭头函数和普通函数的区别
### :rocket: `['1','2','3'].map(parseInt)`的返回值是什么
- `map()`方法创建一个**新数组**，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。
- `map`方法中接受一个函数`function`，用来处理**遍历**数组中的每一个元素。
  `new_array = [].map(function callback(currentValue[,index[,array]]){ // Return element for new_array }[, thisArg]);`
- 这个`callback`一共可以接收三个参数，其中第一个参数代表**当前被处理的元素**，第二个参数代表**该元素的索引**。
- `parseInt`是用来解析字符串，使字符串成为指定基数的整数。接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。`radix`是一个介于2-36之间的整数，返回解析后的整数值。如果被解析参数的第一个字符无法被转化成数值类型，则返回 `NaN`
```
parseInt('1', 0); // radix为0时，使用默认的10进制。
parseInt('2', 1); // radix值在2-36，无法解析，返回NaN
parseInt('3', 2); // 基数为2，2进制数表示的数中，最大值小于3，无法解析，返回NaN
```
- `map` 函数返回的是一个数组，所以最后结果为 `[1, NaN, NaN]`
- 如何返回[1,2,3]?
  - `let res = [`1`,`2`,`3`].map(function(num){return parseInt(num)});`
  - `let res = [`1`,`2`,`3`].map(function(num){return num*1});`
  - `let res = [`1`,`2`,`3`].map(Number);`
### `Set`、`Map`、`WeakMap`、`WeakSet` 区别. `Map` 和 `Object` 的效率问题，各自的 `API`，`WeakMap` 和 `WeakSet` 可迭代吗，JS 垃圾回收机制对 `WeakMap` 和 `WeakSet` 的影响
### `Async`/`await` 实现原理
### `axios` 拦截器、取消功能是怎么实现的
### `Axios` 中会判断使用`fetch`还是`xhr`，其中`fetch`本身是没有`abort`方法的，那么`fetch`怎么实现取消功能？

### Number 精度丢失问题
-  JS Number类型的最大值为2^53 - 1，即MAX_SAFE_NUMBER（这里面试官问到了底层二进制的储存方式，其实就是2^E * M，E为阶码，M为尾码，然后聊到了计算方式，就是求同阶和取大阶等）。解决方案就是使用bigint。
- 这道题本质上和0.1+0.2 === 0.3 //false 是一样的，理解清楚即可。

## Node.js
### 事件循环 :two:
### 原型链的了解
## Vue
### vue组件通信 :four:
- 9种，1. props父传子 2. emit 子传父 3. bus公共事件总线 4. Vuex 5. parent/children 6. Storage 7. provide/inject 8. attrs 9. ref 和 refs
### Vue3相比于Vue2做了哪些改变
### 传参的底层原理 :two:
### Vuex的设计原理
### vue路由`history`和`hash`两种模式的区别
### vue响应式原理 :two:
### Vue 中 `key` 的作用，为什么有高效性？
- 就地复用、`Diff` 算法
### 讲 Vue 如何递归去把数据添加到响应式系统
- `Object.defineProperty`
### 讲 `Dep` 和 `Watcher` 类，Vue 在 `Compile` 阶段如何识别 `data` 数据，实例化 `Watcher` 的过程
- `Dep.target`
###  `computed` 源码

## 工程化
### webpack了解吗
### webpack的`loader`和`plugin`区别
### roxy 代理跨域的实现原理，并要求用 node.js 手写出来一个简单的例子
- （本地 -> 代理服务器 -> 跨域接口）
### 自动化测试有了解吗

## 浏览器
### 强缓存与协商缓存、启发式缓存机制 :three:
- 缓存是性能优化中非常重要的一环。常见缓存机制包括强缓存与协商缓存
- **强缓存**
  - 浏览器中的缓存作用分为两种情况，一种是需要发送 `HTTP` 请求，一种是不需要发送。
  - 检查强缓存: `HTTP/1.0` 时期，使用的是`Expires`，而 `HTTP/1.1` 使用的是`Cache-Control`。
- **协商缓存**
  - 强缓存失效之后，浏览器在请求头中携带相应的缓存 `tag` 来向服务器发请求，由服务器根据这个 `tag` ，来决定是否使用缓存，这就是协商缓存。
  - 缓存`tag`分为两种: `Last-Modified` 和 `ETag`。如果两种方式都支持的话，服务器会优先考虑 `ETag` 。
  - 若资源更新，返回资源和200状态码
  - 否则，返回304，告诉浏览器直接从缓存获取资源

### 浏览器同源策略
### http状态码 :three:
- `RFC` 规定 HTTP 的状态码为三位数，被分为五类
  - **1xx**: 表示目前是协议处理的中间状态，还需要后续操作。
  - **2xx**: 表示成功状态。
  - **3xx**: 重定向状态，资源位置发生变动，需要重新请求。
  - **4xx**: 请求报文有误
  - **5xx**: 服务器端发生错误。

## 跨域
### 跨域解决方案 :three:
### 移动端

## 计算机网络
### 详细介绍`cookie`
- 见下题
### 比较`cookie` `sessionStorage` `localStorage` 区别 :three:
- **Cookie**
  - Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的Application 这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。
  - **缺陷**
    - **容量缺陷**。Cookie 的体积上限只有4KB ，只能用来存储少量的信息。
    - **性能缺陷**。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，会造成巨大的性能浪费的
    - **安全缺陷**。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在 HttpOnly 为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。
- **localStorage**
  - **相同**：就是针对一个域名，即在同一个域名下，会存储相同的一段localStorage。
  - **不同**
    - 容量。localStorage 的容量上限为5M。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。
    - 只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。
    - 接口封装。通过localStorage 暴露在全局，并通过它的 setItem 和 getItem 等方法进行操作，非常方便。
  - **应用场景**：利用localStorage 的较大容量和持久特性，可以利用localStorage 存储一些内容稳定的资源，比如官网的logo ，存储Base64 格式的图片资源，因此利用localStorage
- **sessionStorage**
  - **容量**。容量上限也为 5M。
  - **只存在客户端**，默认不参与与服务端的通信。
  - **接口封装**。除了sessionStorage 名字有所变化，存储方式、操作方式均和localStorage 一样。
  - sessionStorage 只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分sessionStorage 就不复存在了。
  - **应用场景**：
    - 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
    - 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用sessionStorage 就再合适不过了。事实上微博就采取了这样的存储方式。
- **IndexedDB**
  - IndexedDB 是运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。
  - **特性**
    - 支持事务
    - 存储二进制数
    - 键值对存储
    - 异步操作
    - 受同源策略限制，即无法访问跨域的数据库。
- **总结**
  - cookie 并不适合存储，而且存在非常多的缺陷。
  - Web Storage 包括localStorage 和sessionStorage , 默认不会参与和服务器的通信。
  - IndexedDB 为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口。

### 怎么保护`cookie`不被泄露
### 介绍`token`，具体原理，怎么应用
### 详细介绍XSS，CSRF, 怎么防范，它们之间的区别 :two:
- :question: 回答了前后端过滤，加密等方法，但是面试官深问怎么加密，如何过滤，具体方法，没答出来。
### HTTPS 和 HTTP 区别 :two:
1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
2. HTTP ：TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
4. 如果使用HTTPS 协议，服务器需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

### HTTPS的加密算法
- **概述**
  1. 使用非对称加密算法（公钥和私钥）交换对称加密中使用的密钥
  2. 数字证书验证身份（验证公钥是否是伪造的）
  3. 利用对称密钥加解密后续传输的数据
- **解决的问题**
  - 窃听风险：信息加密
  - 篡改风险：校验机制
  - 冒充风险：身份证书

### HTTP1.1、HTTP2.0、HTTP3.0改进 :two:
#### HTTP1.1
- **改进**：
  - 增加TCP长连接
  - 支持管道传输(已放弃)
- **不足**：
  - 请求 / 响应头部（Header）未经压缩就发送
  - 队头阻塞：服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据；
  - 没有请求优先级控制
  - 请求只能从客户端开始，服务器只能被动响应
#### HTTP2.0
- **改进**
  - 头部**压缩**：消除重复的部分；维护一张头信息表，只发送索引号
  - **二进制格式**：增加了数据传输的效率
  - 数据流：数据包**不是按顺序发送的**；具有**编号**，客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数；指定数据流的**优先级**
  - 多路复用：降低了延迟，大幅度提高了连接的利用率
  - 服务器推送
    - 可以主动向客户端发送消息
    - 减少延时的等待
- **不足**
  - TCP 队头阻塞
  - TCP 建立连接的延时
  - TCP 协议僵化
#### HTTP3.0
-   HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP

### 说一说从输入URL到页面呈现发生了什么
- **网络请求**
  1. **浏览器会构建请求行**：
    请求方法 + 请求 `URL` + `http` 版本
  2. **查找强缓存**
    先检查强缓存，如果命中直接使用，否则进入下一步。
  3. **DNS解析**：
    - 由于输入的是域名，而数据包是通过IP地址传给对方的。因此我们需要得到域名对应的IP地址。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，这个系统就叫做 `DNS` （域名系统）。得到具体 IP 的过程就是 `DNS` 解析。
    - 浏览器提供了 `DNS` 数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 `DNS` 解析。
  4. **建立 TCP 连接**
    - 等待：Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请求就得等待。
    - 连接
      - 通过三次握手(即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接。
      - 进行数据传输。接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。
  5. **发送 HTTP 请求**
    - 请求行：由请求方法、请求`URL`和 `HTTP` 版本协议组成。
    - 请求头
    - 请求体：请求体只有在 `POST` 方法下存在，常见的场景是表单提交。
- **网络响应**
  - 返回网络响应：跟请求部分类似，网络响应具有三个部分:响应行、响应头和响应体。
    - 响应行：由`HTTP`协议版本、状态码和状态描述组成。
    - 响应头：包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的`Cookie`信息。
  - 判断 `Connection` 字段, 如果请求头或响应头中包含`Connection: Keep-Alive`，表示建立了持久连接，这样`TCP` 连接会一直保持，之后请求统一站点的资源会复用这个连接。否则断开 `TCP` 连接, 请求-响应流程结束。
  - 通过四次挥手来断开连接。
### dns解析是怎么的过程


## 设计模式

## 服务器端渲染
### 服务器端渲染，解决了哪些问题

## 性能
### 首屏加载优化
### 性能优化(包体积优化、懒加载预加载优化，SSR优化)

# 算法
## 数据结构
### 数组去重，有几种方法 :two:
### 判断回文序列
### 数组相邻k个元素最大子序列求和
### 青蛙跳台
### 手写斐波那锲数列
### 手写翻转二叉树
### 最大传递次数
- 题：假设一共有 n 个人，给出一个数组指出哪些人可以把东西传给哪些人？最大传递次数为k。计算传给第 n-1 个人一共有几种方式，传不到返回0
- Example: `n = 5, arr = [[0, 2], [0, 4], [2, 1], [1, 3], [4, 1], [2, 3], [3, 4]], k = 3`
### 二叉树求路径和


## 应用
### `promise`类 :five:
- <a src="https://juejin.cn/post/6850037281206566919">手写promise</a>
### 手写获取数组的重复元素
- `filter`方法
- `map`记录出现次数
- 新创建一个数组空间
### 正则匹配
### 手写发布订阅模式，订阅，触发，移除 :two:
### 完成一个函数，从淘宝网获取所有图片信息返回所有`url`序列，之后从中截取每张图片的名称，并根据每张图片的大小排序返回并下载。
- :question: 用正则表达式
### 根据表达式计算字母数量
- **描述**：输入一串字符串，根据字符串求出每个字母的数量并返回结果对象。（数字为1时可省略）
- **示例一**：输入：`A3B2`，输出：`{"A": 3, "B": 2}`
- **示例二**：输入：`A(A(A2B)2)3C2`，输出：`{"A": 16, "B": 6, "C": 2}`
### 节流、防抖 :two:
- <a src="https://juejin.cn/post/6959094874264043533">参考</a>
- - <a src="https://juejin.cn/post/6894535259544059917#chapter-three-one">参考</a>
#### lodash
#### 手写防抖
- 每次事件触发后总是等待一段时间执行，如果在等待时间内事件再次触发，则重新计算等待时间（停止触发的时候只会执行一次,最后一次生效）
#### 手写节流
- **描述**：参数一：执行的函数，参数二：时间间隔。要求实现即使函数被连续触发多次也只在连续时间内执行一次。
- **答案**
  ```
  function throttle(func, time) {
    let timeout;
    return function () {
        if (!timeout) {
            func.apply(this, arguments);
            timeout = setTimeout(() => {
                timeout = null;
            }, time);
        }
    };
    }
  ```
### 对象扁平化
<a src = "https://www.nowcoder.com/discuss/860063?source_id=discuss_experience_nctrack&channel=-1">网页链接</a>

### 手写 `instanceof`

## 设计模式
### 手写观察者模式

# 场景题
## 实际应用
### :rocket: 三栏布局 :two:
- **流体布局**
  - 左右模块各自向左右浮动，并设置中间模块的 `margin` 值使中间模块宽度自适应。
  - 缺点就是**主要内容无法最先加载**，当页面内容较多时会影响用户体验。
- **BFC 三栏布局**
  - BFC 规则有这样的描述：BFC 区域，不会与浮动元素重叠。因此我们可以利用这一点来实现 3 列布局。
  - 缺点跟方法一类似，主要内容模块无法最先加载，当页面中内容较多时会影响用户体验。因此为了解决这个问题，有了下面要介绍的布局方案双飞翼布局。
- **双飞翼布局**
  - 利用的是浮动元素 `margin` 负值的应用，感兴趣的同学可以上网搜搜原理。
  - 主体内容可以优先加载，HTML 代码结构稍微复杂点。
  - **写法**
    - 左右外模块均向左浮动
    - 外模块宽度设置为100%
    - 左模块左外边距-100%，右模块左边距负自身宽度
    - 设置外模块内/外边距给左右子面板留出空间
- **圣杯布局**
  - 跟双飞翼布局很像，有一些细节上的区别，相对于双飞翼布局来说，HTML 结构相对简单，但是样式定义就稍微复杂，也是优先加载内容主体。
  - **写法**
    - 三者均向左浮动
    - 中间模块宽度设置为100%
    - 左模块左外边距-100%，右模块左边距负自身宽度
    - 设置外模块内/外边距给左右子面板留出空间
    - 设置两个子面板为相对定位，左模块left值为负宽度，右模块right值为负宽度
  - 当面板的main部分比两边的子面板宽度小的时候，布局就会乱掉。
- **Flex 布局**
  - 简单实用，未来的趋势，需要考虑浏览器的兼容性。
- **Grid 布局**
  - `grid-template-columns` 设置各栏宽度
  - `grid-column-gap` 设置间距
- **Table 布局**
  - 缺点：无法设置栏间距
- **绝对定位布局**
  - 简单实用，并且主要内容可以优先加载。
- 参考
  - <a src="https://zhuanlan.zhihu.com/p/25070186">详解 CSS 七种三栏布局技巧</a>
  - <a src="https://segmentfault.com/a/1190000023797030">CSS三栏布局——圣杯布局、双飞翼布局和flex布局</a>

### grid布局
- 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。
- <a src="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">Grid</a>
### position几种属性，以及应用场景
- position 属性指定了元素的定位类型
- static:HTML 元素的默认值，即没有定位，遵循正常的文档流对象。
- fixed:元素的位置相对于浏览器窗口是固定位置。
- relative:相对定位元素的定位是相对其正常位置。
- absolute:绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于`<html>`
- sticky:粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。
### 如何判断元素出现在可视区域
- 判断元素距离文档顶部的距离和视图窗口高度和滚动过距离和的大小关系
- `getBoundingClientRect`
- `IntersectionObserver`
### :rocket: 实现水平垂直居中 :three:
方法|居中元素</br>定宽高固定|PC兼容性|移动端兼容性
| :---: | :---: | :---: | :---:|
`absolute` + 负`margin`|是|IE6+, Chrome4+, Firefox2+|安卓2.3+, iOS6+
`absolute` + `margin auto`|是|IE6+, Chrome4+, Firefox2+|安卓2.3+, iOS6+
`absolute` + `calc`|是|IE9+, Chrome19+, Firefox4+|安卓4.4+, iOS6+
`absolute` + `transform`|否|IE9+, Chrome4+, Firefox3.5+|安卓3+, iOS6+
`writing-mode`|否|IE6+, Chrome4+, Firefox3.5+|安卓2.3+, iOS5.1+
`lineheight`|否|IE6+, Chrome4+, Firefox2+|安卓2.3+, iOS6+
`table`|否|IE6+, Chrome4+, Firefox2+|安卓2.3+, iOS6+
`css-table`|否|IE8+, Chrome4+, Firefox2+|安卓2.3+, iOS6+
`flex`|否|IE10+, Chrome4+, Firefox2+|安卓2.3+, iOS6+
`grid`|否|IE10+, Chrome57+, Firefox52+|安卓6+, iOS10.3+
- 概述：
  - **PC端**有兼容性要求，宽高固定，推荐`absolute` + 负`margin`
  - **PC端**有兼容要求，宽高不固定，推荐`css-table`
  - **PC端**无兼容性要求，推荐`flex`
  - **移动端**推荐使用`flex`
- 参考：<a src = "https://yanhaijing.com/css/2018/01/17/horizontal-vertical-center/">CSS实现水平垂直居中的10种方式</a>

### css怎么画一个大小为父元素面积一半的正方形
1. 斜正方形，顶点在正方形各边中点上
2. 内正方形，边长为根号2
### :rocket: `flex`实现8个元素分两行排列 每行4个平均分布
- `display: flex;`
- `flex-wrap: wrap;`
### :rocket: 单行文本省略，多行文本省略分情况实现
- 单行
  ```
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  ```
- 两行
  ```
  overflow:hidden;
  text-overflow:ellipsis;
  display:-webkit-box;
  -webkit-box-orient:vertical;
  -webkit-line-clamp:2;
  ```

## 框架设计
### 设计一个微前端框架需要注意哪些方面？隔离，子应用资源加载分别怎么做？

# 项目
## 陈述
### inSight前端
- `STAR`法则
  - 情境(situation)：描述工作的背景
  - 任务(task)
  - 行动(action)
  - 结果(result)
- 使用更流程通用的 css3：scale 缩放方案，通过 ref 指向 views/index，屏幕改变时缩放内容。项目的基准尺寸是 1920px*1080px，所以支持同比例屏幕 100% 填充，如果非同比例则会自动计算比例居中填充，不足的部分则留白。
### inSight客户端

## 提问
### 项目做了哪些事情？
### 项目过程遇到了哪些难点？
### 项目介绍，挑战、难点、解决方案