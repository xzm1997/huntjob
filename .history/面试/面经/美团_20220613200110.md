# 综合类
1. 自我介绍
2. 如何去接触前端的？有用过什么工具书吗？
3. 介绍一下你简历中的一个项目
4. 通过哪些途径学习
5. 学习前端方法
6. 英语怎么样
7. 未来的计划有考虑过吗
8. 平时研发实践多吗
# HTML
1. DOCTYPE，分类
  DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是**告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档**，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。
  - 标准模式：浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。
  - 怪异模式(混杂模式)：浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。
# CSS
1. 盒模型，以及`box-sizing:border-box`使用场景，这两者的区别
   - CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：**边距**，**边框**，**填充**，和**实际内容**。
2. flex弹性布局 :two:
   - Flex是FlexibleBox的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，**子元素的float、clear和vertical-align属性将失效**。采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。
   - Flex整个宽度不够的话会做什么处理？
3. CSS有哪些伪类，实现选择偶数个对象元素的伪类是什么
   - **种类**
     - **静态伪类**：只能用于超链接的样式
      - `:link` 超链接点击之前
      - `:visited` 链接被访问过之后
     - **动态伪类**：针对所有标签都适用的样式
       - `:hover` “悬停”：鼠标放到标签上的时候
       - `:active` “激活”： 鼠标点击标签，但是不松手时。
       - `:focus` 是某个标签获得焦点时的样式（比如某个输入框获得焦点）
# JavaScript
1. 代码输出结果：this上下文
2. `===`和`==`
3. 变量的隐式转换
   - `+`: `+`操作符的两边有至少一个`string`类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。
   - `==`: 操作符两边的值都尽量转成`number`
   - `<` 与 `>`：如果两边都是字符串，则比较字母表顺序；其他情况下，转换为数字再比较
   - 对象会被`ToPrimitive`转换为基本类型再进行转换
4. let 和 var
5. js的垃圾回收机制
   - 回收算法
     - 标记清理
     - 引用计数
   - V8的回收机制
     - 分代回收机制
     - 标记清除 & 整理
6. 闭包 :two:
   -闭包是js的一种特性，我们可以通过闭包实现**函数内外部的连接**，并且可以使得函数的局部变量始终存在于内存中。
   - 匿名自执行函数还可以用于在js中模拟创建**块级作用域**，即如果使用匿名自执行函数将某些代码包裹起来可以实现块级作用域的效果，**减少全局变量的数量**，在匿名自执行函数执行结束后变量就会被内存释放掉，从而也会节省了内存。
   - 闭包允许内层函数引用父函数中的变量，但该变量是最终值
   - 闭包内变量要到整个闭包被清除的时候才会清除，比如局部变量要等到函数执行完之后。
   - 闭包是指有权访问另一个函数作用域中变量的函数；
7. js的异步
8. promise.finally是原型方法还是静态方法
- 原型方法：`then`, `catch`, `finally`
- 静态方法：`all`, `race`, `reject`, `resolve`, `allSettled`, `any`
9. promise怎么阻止它继续执行
   - 在程序中，只要返回了一个 promise 对象，如果 promise 对象不是 Rejected 或 Fulfilled 状态，then 方法就会继续调用。利用这个特性，可以处理多个异步逻辑。但有时候某个 then 方法的执行结果可能会决定是否需要执行下一个 then，这个时候就需中止 promise，主要思想就是使用 reject 来中止 promise 的 then 继续执行。
10. async/await如果右边方法执行出错该怎么解决
    - 使用`Promise.catch`捕获
    - 使用 `try-catch`
11. `generator`的原理
    - 生成器从本质上来说，是一种特殊的迭代器
12. `call`/`apply`/`bind`的区别
    - 重新**定义**`this`对象
    - `apply`和`call`会使当前函数立即执行，`bind`会返回一个函数，后续需要时再调用
    - `call`中要传多个任意参数，`apply`只可以直接传数组或者类数组
13. JS的深浅拷贝
    - 浅拷贝
      - `Object.assign()`: 可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。
      - 函数库`lodash的_.clone`方法
      - 展开运算符`...`
      - `Array.prototype.concat()`
      - `Array.prototype.slice()`
    - 深拷贝
      - 利用`JSON.stringify`将对象转成`JSON`字符串，再用`JSON.parse`把字符串解析成对象
      - 函数库`lodash的_.cloneDeep`方法
      - `jQuery.extend()`方法
      - 手写递归方法
14. ES6了解哪些，set，箭头函数和一般函数的区别
15. 事件委托与事件捕获
    - 事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。
    - 从外向内
# Vue
1. 父子组件、兄弟组件的通信方式 :two:
   - 通信总线：`$emit` / `$on`，通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件
   - prop、$emit
   - `$parent` / `$children` 与 `ref`
   - vuex
2. 双向绑定
   - 通过数据劫持结合发布者-订阅者模式的方式来实现的，首先是对数据进行监听，然后当监听的属性发生变化时则告诉订阅者是否要更新，若更新就会执行对应的更新函数从而更新视图
   - Object.defineProperty() 与 proxy()
3. hash和history
   - hash模式
     - 基于浏览器的hashchange事件，地址变化时，通过window.location.hash 获取地址上的hash值；并通过构造Router类，配置routes对象设置hash值与对应的组件内容。
     - 优点
       - hash值会出现在URL中, 但是不会被包含在Http请求中, 因此hash值改变不会重新加载页面
       - hash改变会触发hashchange事件, 能控制浏览器的前进后退
       - 兼容性好
     - 缺点
       - 地址栏中携带#，不美观
       - 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL
       - hash有体积限制，故只可添加短字符串
       - 设置的新值必须与原来不一样才会触发hashchange事件，并将记录添加到栈中
       - 每次URL的改变不属于一次http请求，所以不利于SEO优化
   - history模式
     - 基于HTML5新增的`pushState()`和`replaceState()`两个api，以及浏览器的popstate事件，地址变化时，通过`window.location.pathname`找到对应的组件。并通过构造Router类，配置routes对象设置pathname值与对应的组件内容。
     - 优点
       - 没有#，更加美观
       - `pushState()` 设置的新 URL 可以是与当前 URL 同源的任意 URL
       - `pushState()` 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中
       - `pushState()` 通过 stateObject 参数可以添加任意类型的数据到记录中
       - `pushState()` 可额外设置 title 属性供后续使用
       - 浏览器的进后退能触发浏览器的`popstate`事件，获取`window.location.pathname`来控制页面的变化
     - 缺点
       - URL的改变属于http请求，借助history.pushState实现页面的无刷新跳转，因此会重新请求服务器。所以前端的 URL 必须和实际向后端发起请求的 URL 一致。如果用户输入的URL回车或者浏览器刷新或者分享出去某个页面路径，用户点击后，URL与后端配置的页面请求URL不一致，则匹配不到任何静态资源，就会返回404页面。所以需要后台配置支持，覆盖所有情况的候选资源，如果 URL 匹配不到任何静态资源，则应该返回app 依赖的页面或者应用首页。
       - 兼容性差，特定浏览器支持
4. VUE的生命周期
5. Vue的双向数据绑定怎么实现的
6. Vue中v-if和v-show的区别
# 浏览器
1. 单页面与多页面的区别？单页应用如何在浏览器中实现的？单页应用的优缺点
2. 跨域的具体实现 :four:
   - img的src也可以跨域吗?
     - 原理是相同的，都是利用标签的src属性可以跨域请求的特点，但是具体的实现不同。使用img标签不能访问服务器返回的响应内容，也就是说只能单向的发送get请求；而使用script标签实现的jsonp跨域可以将服务器响应文本以函数参数的形式返回，浏览器解析js代码时直接就执行了。
3. 浏览器的同源规则？
4. 浏览器的缓存
5. 强缓存和协商缓存的首部字段，这些字段分别是在http协议的哪些阶段出现的
6. 浏览器性能的优化 :two:
  - 如何进行网站的性能优化，可以从哪些方面进行优化
6. js代码要放在body后面，为什么这么做呢
7. cookie和session
8. diff算法
9. 缓存处理有哪些思路
10. 浏览器有哪些方法可以实现缓存数据
    - sessionStorage和localStorage、cookie
11. 回流与重绘
12. 点击按钮，页面刷新展示的过程（分局部刷新和页面整体刷新）
13. 事件循环原理
# node
- 事件循环
- commonjs原理
# 设计模式
- JS的设计模式
- 适配器模式
- MVC/MVVM，挑一个你熟悉的说说
# 计算机网络
1. GET和POST的区别
2. 状态码
   - 解释状态码304到200的过程？
3. http和https有什么区别
4. SSL的过程是什么
5. 加密算法有哪些
6. TCP和UDP的区别是什么
7. TCP的流量控制的机制是什么？讲一下滑动窗口？
8. DNS域名解析
# 部署
- git常见命令
- 前端模块化
# 应用
1. 骨架屏是怎么实现的
   - 骨架屏就是在页面资源尚未加载完成以及渲染尚未完成 时需要先给用户的展示页面大致结构。直到资源加载完成以及渲染完成后 使用渲染的页面。
   - 实现
     - 首屏：可以在index.html模版中手写骨架屏相关代码。
     - 其他页面：可以利用UI提供SVG图
   - 参考：<a src="https://segmentfault.com/a/1190000040178183">实现骨架屏的方案</a>
# 项目
1. 项目中多入口打包是什么实现的，为什么这么做
2. 项目中技术栈的选择
3. 项目的技术点有哪些
4. 项目遇到的最大的困难
# 场景题
1. 三栏布局，有几种方法
2. 从字面向量构建的对象中查找属性
# 算法
0. ！！在线笔试题
1. 找出不大于x（x 为大于1的整数) 的所有质数。质数的意思，只能被自身和1整除
2. 输出 `abcd`全排列的所有结果
3. 数组去重
   - 如何只遍历一次？
4. 堆排序
5. 反转单向链表
6. 怎样判断一个字符串是否是回文串
7. 假如对所有中国人的身高进行排序，精确到1cm，时间复杂度最小的办法是什么
8. 二叉树的深度优先遍历和广度优先遍历选一个编写代码
9. 怎样检测单向链表有没有环，怎么样去除环？
10. 实现一个单链表，结构+插入+查询+删除
11. 实现一个reverse方法
12. 牛牛的数列
13. 撕代码：单词消消乐
14. 通过栈数据结构封装队列
15. 镜像二叉树算法；
16. 手写数组扁平化
17. 洗牌算法；
18. js实现哈希表存储算法
